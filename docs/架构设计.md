# wunder 架构设计（代码对齐版）

本文档根据当前 src 目录实现整理，面向研发和运维说明系统的部署形态、模块职责、核心链路、并发隔离和治理机制。

## 1. 设计目标

- 统一入口。通过 wunder 系列接口统一承接模型、工具、知识库、技能与工作区能力。
- 接口抽象。对开发者来说能力是接口，对模型来说能力是工具。
- 多用户并发。支持虚拟用户和注册用户并存，保证高并发下的稳定执行。
- 可观测可治理。请求、工具、模型和事件可追踪可回放。
- 长期可维护。模块清晰，配置可更新，存储后端可切换。

## 2. 部署拓扑和运行模式

### 2.1 双模式二进制

同一个 wunder-server 二进制支持两种运行模式。

- api 模式。对外提供聊天、管理、渠道、网关、A2A 和 MCP 路由。
- sandbox 模式。提供独立沙盒接口，用于命令执行和 ptc 隔离。

### 2.2 典型服务组件

#### 部署拓扑图

```mermaid
flowchart LR
  subgraph Clients["访问方"]
    UserUI["用户侧前端(生产)"]
    DebugUI["调试前端(开发)"]
    AdminUI["管理端调试 UI"]
    ApiClient["API/SDK 调用方"]
  end

  subgraph Runtime["运行服务"]
    Nginx["前端静态服务<br/>wunder_nginx"]
    FrontendDev["前端开发服务<br/>wunder_frontend"]
    RustAPI["核心服务/网关<br/>wunder_server"]
    Sandbox["沙盒<br/>sandbox"]
    MCP["MCP 服务<br/>wunder_mcp"]
    PG[("数据库<br/>postgres")]
    VectorDB["向量数据库<br/>Weaviate"]
  end

  subgraph RightSide[" "]
    direction TB
    subgraph External["外部依赖"]
      LLM["大模型 API"]
      ExtDB["业务数据库"]
      KB["RAG 知识库/外部工具"]
    end
    subgraph Mounts["挂载目录"]
      WS[("Workspaces 卷")]
    end
  end

  UserUI -->|静态资源| Nginx
  DebugUI -->|静态资源| FrontendDev

  UserUI -->|HTTP/SSE/WS| RustAPI
  DebugUI -->|HTTP/SSE/WS| RustAPI
  AdminUI -->|HTTP/SSE/WS| RustAPI
  ApiClient -->|HTTP/SSE/WS| RustAPI

  RustAPI --> PG
  RustAPI --> WS
  RustAPI --> LLM
  RustAPI --> VectorDB
  RustAPI --> Sandbox
  RustAPI --> MCP

  MCP --> ExtDB
  MCP --> KB

  classDef client fill:#eef6ff,stroke:#5b8ff9,stroke-width:1.2px,color:#1d39c4;
  classDef runtime fill:#fff7e6,stroke:#fa8c16,stroke-width:1.2px,color:#873800;
  classDef external fill:#f6ffed,stroke:#73d13d,stroke-width:1.2px,color:#135200;
  classDef volume fill:#f5f5f5,stroke:#bfbfbf,stroke-width:1.2px,color:#434343;

  class UserUI,DebugUI,AdminUI,ApiClient client;
  class Nginx,FrontendDev,RustAPI,Sandbox,MCP,PG,VectorDB runtime;
  class LLM,ExtDB,KB external;
  class WS volume;

  style Clients fill:#f0f5ff,stroke:#adc6ff,stroke-width:1px,color:#1f1f1f;
  style Runtime fill:#fff7e6,stroke:#ffd591,stroke-width:1px,color:#1f1f1f;
  style External fill:#f6ffed,stroke:#b7eb8f,stroke-width:1px,color:#1f1f1f;
  style Mounts fill:#ffffff,stroke:#d9d9d9,stroke-width:1px,color:#1f1f1f;
  style RightSide fill:transparent,stroke:transparent,color:transparent;
```

- wunder_server。Rust Axum 主服务。
- sandbox。沙盒执行服务，运行相同二进制的 sandbox 模式。
- postgres。主数据库。
- weaviate。向量检索后端。
- frontend。用户侧前端。
- web。管理端静态页面。
- wunder_mcp。可选外部 MCP 服务。系统内部同时也提供 wunder mcp 路由。

## 3. Rust 内部逻辑架构

### 3.1 模块边界

#### 逻辑架构图

```mermaid
flowchart TB
  API[api 路由层] --> POLICY[鉴权 配额 限流]
  POLICY --> RUNTIME[AgentRuntime]
  RUNTIME --> ORCH[Orchestrator]

  ORCH --> PROMPT[prompt和context]
  ORCH --> LLM[llm 调用]
  ORCH --> TOOLCALL[tool_calls和tool_exec]
  ORCH --> EVENTS[event_stream]
  ORCH --> COMPACT[memory compaction]

  TOOLCALL --> BUILTIN[内置工具]
  TOOLCALL --> MCPTOOLS[MCP A2A Skills]
  TOOLCALL --> USERTOOLS[用户工具]
  TOOLCALL --> KNOWLEDGE[knowledge和vector_knowledge]

  ORCH --> STORAGE[StorageBackend]
  STORAGE --> PG[(Postgres)]
  STORAGE --> SQ[(SQLite)]
```

- api。HTTP 和 WebSocket 路由层，按 chat、admin、channel、cron、evaluation、gateway、a2a 等领域拆分。
- orchestrator。调度核心，负责上下文、模型轮次、工具编排、事件流和会话锁。
- services。业务服务层，包括 AgentRuntime、Workspace、Memory、Tools、MCP、Cron、UserStore、Knowledge。
- channels。外部渠道接入和回包，包括 WhatsApp、Feishu、QQ 及出站队列。
- gateway。控制平面，维护节点连接状态并支持 node invoke。
- storage。StorageBackend 抽象以及 Postgres 和 SQLite 实现。
- ops。监控、压测、性能采样、评估运行器。
- lsp。按用户和项目根动态维护 LSP 客户端。
- sandbox。沙盒服务端逻辑。

### 3.2 AppState 组装

#### AppState 依赖关系

```mermaid
flowchart LR
  CFG[ConfigStore] --> APP[AppState]
  STG[StorageBackend] --> APP
  WS[WorkspaceManager] --> APP
  MON[MonitorState] --> APP
  ORCH[Orchestrator] --> APP
  RT[AgentRuntime] --> APP
  CH[ChannelHub] --> APP
  GW[GatewayHub] --> APP
  CRON[CronScheduler] --> APP
  LSP[LspManager] --> APP
  USER[UserStore] --> APP
```

AppState 在启动时统一组装以下核心组件。

- ConfigStore
- StorageBackend
- WorkspaceManager
- MonitorState
- Orchestrator
- AgentRuntime
- UserStore
- UserToolStore
- UserToolManager
- ChannelHub
- GatewayHub
- CronScheduler
- ThroughputManager
- EvaluationManager
- LspManager
- MemoryStore

## 4. 三条关键运行链路

### 4.1 聊天主链路

#### 对话链路时序图

```mermaid
sequenceDiagram
  participant U as 调用方
  participant API as API 路由
  participant AR as AgentRuntime
  participant O as Orchestrator
  participant T as Tooling
  participant S as Storage

  U->>API: POST /wunder
  API->>AR: submit_user_request
  alt 主线程忙且队列开启
    AR->>S: 写入 agent_tasks pending
    AR-->>U: 返回 queued
  else 直接执行
    AR->>O: execute_stream
    O->>S: 获取 session_locks 和历史
    loop 模型轮次
      O->>O: 构建上下文和提示词
      O->>O: 调用 LLM
      alt 产生工具调用
        O->>T: 执行工具
        T-->>O: 工具结果
      end
      O->>S: 写入 chat_history tool_logs stream_events
    end
    O-->>U: WS 事件流或 SSE 兜底
    O->>S: 回写会话状态
  end
```

1. 请求进入 wunder 或 chat 路由。
2. resolve_user 完成身份解析，支持 token、api key 和虚拟 user_id。
3. AgentRuntime 解析主会话和排队策略。
4. Orchestrator 获取会话锁并构建上下文，执行模型和工具循环。
5. 事件流写入监控和 stream_events，最终回答落库并返回。

### 4.2 渠道接入链路

#### 渠道链路图

```mermaid
flowchart LR
  W[Webhook 入站] --> C[ChannelHub]
  C --> B[绑定匹配与会话策略]
  B --> M[多模态预处理]
  M --> A[AgentRuntime]
  A --> O[Orchestrator]
  O --> R[回复文本和事件]
  R --> OB[channel_outbox]
  OB --> D[后台投递和重试]
```

1. 渠道 webhook 进入 channel 路由。
2. ChannelHub 完成账号校验、绑定匹配、会话策略选择。
3. 多模态前处理执行 asr、ocr、地理描述和附件桥接。
4. 调用 Orchestrator 生成回复。
5. 回复写入 channel_outbox 并由后台 worker 重试投递。

### 4.3 网关控制平面链路

#### 网关控制平面图

```mermaid
sequenceDiagram
  participant Node as node或operator
  participant WS as gateway_ws
  participant Hub as GatewayHub
  participant DB as Storage

  Node->>WS: 连接与握手
  WS->>Hub: register_client
  Hub->>DB: upsert gateway_clients和gateway_nodes
  WS-->>Node: welcome和presence
  Node->>WS: gateway.response 或 event
  WS->>Hub: forward 或 broadcast
  Hub->>DB: 更新 last_seen 与节点状态
```

1. 客户端连接 gateway ws 路由并完成握手。
2. GatewayHub 注册连接并维护 role、caps、commands、node 索引。
3. 管理端可拉取 presence，执行 node invoke。
4. 网关事件广播和慢客户端驱逐由 Hub 统一处理。

## 5. 工具体系和知识体系

### 5.1 工具池构成

系统在请求时按权限和配置动态汇总工具池，来源包括：

- 内置工具
- MCP 工具
- A2A 服务工具
- Skills 工具
- 字面知识库工具
- 向量知识库工具
- 用户自建工具和共享工具

### 5.2 知识库双轨模型

#### 向量知识库流程图

```mermaid
flowchart LR
  UP[上传文档] --> PARSE[doc2md 或文本解析]
  PARSE --> CHUNK[切片和chunks_json]
  CHUNK --> META[(vector_documents)]
  CHUNK --> EMBED[embedding 模型]
  EMBED --> VDB[(Weaviate)]

  Q[检索请求] --> QEMBED[查询向量化]
  QEMBED --> VDB
  VDB --> HITS[相似片段]
  META --> HITS
  HITS --> CTX[拼装检索上下文返回给 Orchestrator]
```

- 字面知识库。按文档章节解析和候选召回，可结合 LLM 重排。
- 向量知识库。文档切片后写入向量后端，关系库存储元数据和切片结构。

## 6. 并发和隔离模型

### 6.1 隔离维度

- 会话执行隔离。粒度为 session_id。
- 主线程隔离。粒度为 user_id 加 agent_id。
- 工作区隔离。粒度为 user 作用域和容器作用域。
- 身份隔离。虚拟用户可调用调度链路，注册用户参与账号治理和配额治理。

### 6.2 锁和队列

#### 会话锁与排队关系图

```mermaid
flowchart LR
  U[user_id] --> TH[agent_threads user_id+agent_id]
  TH --> CS[chat_sessions 主会话]
  CS --> LK[session_locks]
  TH --> AQ[agent_tasks]
  AQ --> WK[AgentRuntime worker]
  WK --> OR[Orchestrator]
  OR --> EV[stream_events 和 monitor_sessions]
```

- session_locks 负责会话互斥和心跳续租。
- 开启 agent_queue 时，忙请求进入 agent_tasks，由后台循环消费。

### 6.3 轮次模型

- 用户轮次。用户每次发送消息增加一轮。
- 模型轮次。模型每次动作增加一轮，动作包含模型调用、工具调用或最终回复。

## 7. 存储与状态设计

- 通过 StorageBackend 屏蔽后端差异，支持 postgres、sqlite、auto。
- 启动阶段自动建表、补列和补索引，减少迁移阻塞。
- 写入采用异步队列降低主链路阻塞。
- cleanup_retention 按天清理核心日志表，并保护管理员数据。

## 8. 安全与治理

- 管理接口采用 api key 和管理员 token 双通道鉴权。
- 执行安全由 allow_commands、allow_paths、deny_globs 和 sandbox 共同约束。
- 渠道接入支持 token 或签名校验。
- 网关支持 origin 限制、trusted proxy 和节点 token 策略。
- 配额和访问控制由用户、组织、工具和智能体访问策略共同完成。

## 9. 可观测性与性能要点

- MonitorState 维护会话状态机和事件回放。
- 流式默认使用 WebSocket，SSE 作为兜底。
- 断线后可基于事件 id 恢复。
- 内置吞吐压测、性能采样和评估体系。
- 多处采用缓存和后台 worker 控制延迟与内存抖动。

## 10. 后续扩展建议

- 新能力优先按工具方式接入，避免破坏调度主链路。
- 新通信能力优先接入 WebSocket，SSE 仅保底。
- 数据层扩展优先新增表和索引，保持原型阶段迭代速度。
