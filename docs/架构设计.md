# wunder 架构设计

本文档基于当前仓库实现对 wunder 的部署形态、核心组件与关键流程进行架构说明，方便理解整体运行方式与后续扩展方向。

## 1. 设计目标

- 统一对外入口：通过 `/wunder` 承载多模型、多工具、多流程的统一调度。
- 多用户隔离：以 `user_id` 划分工作区与会话状态，支持虚拟用户与注册用户并存。
- 可观测与可治理：流式事件、监控、评估与额度治理形成闭环。
- 长期稳定：Rust + Axum 高性能服务、沙盒隔离与存储持久化满足长期运行。

## 1.1 设计原则与权衡

- 接口优先：模型与工具以统一接口封装，便于替换与扩展，不让业务逻辑依赖具体供应商细节。
- 软隔离 + 硬隔离：会话与工作区按 `user_id + agent_id` 隔离，高风险执行进入沙盒，平衡安全与性能。
- 流式可观测：SSE 事件贯穿全链路，既服务用户体验也支撑监控与诊断。
- 可扩展但可治理：工具、知识库与技能可扩展，同时配合权限策略与配额治理避免系统失控。

## 2. 部署拓扑

```mermaid
flowchart LR
  subgraph Clients["访问方"]
    UserUI["用户前端"]
    AdminUI["管理前端"]
    ApiClient["API/SDK 调用方"]
  end

  subgraph Runtime["运行服务"]
    Nginx["前端<br/>wunder_nginx"]
    RustAPI["核心<br/>wunder_rust"]
    Sandbox["沙盒<br/>sandbox"]
    MCP["MCP服务<br/>wunder-mcp"]
    PG[(数据库<br/>postgres)]
    VectorDB["向量数据库<br/>Weaviate"]
  end

  subgraph RightSide[" "]
    direction TB
    subgraph External["外部依赖"]
      LLM["大模型 API"]
      ExtDB["业务数据库"]
      KB["RAG知识库"]
    end
    subgraph Mounts["挂载目录"]
      WS[(Workspaces 卷)]
    end
  end

  UserUI -->|静态资源| Nginx
  UserUI -->|HTTP/SSE| RustAPI
  AdminUI -->|静态资源 + API| RustAPI
  ApiClient -->|HTTP/SSE| RustAPI

  RustAPI --> PG
  RustAPI --> WS
  RustAPI --> LLM
  RustAPI --> VectorDB
  RustAPI --> Sandbox
  RustAPI --> MCP

  MCP --> ExtDB
  MCP --> KB

  classDef client fill:#eef6ff,stroke:#5b8ff9,stroke-width:1.2px,color:#1d39c4;
  classDef runtime fill:#fff7e6,stroke:#fa8c16,stroke-width:1.2px,color:#873800;
  classDef external fill:#f6ffed,stroke:#73d13d,stroke-width:1.2px,color:#135200;
  classDef volume fill:#f5f5f5,stroke:#bfbfbf,stroke-width:1.2px,color:#434343;

  class UserUI,AdminUI,ApiClient client;
  class Nginx,RustAPI,Sandbox,MCP,PG,VectorDB runtime;
  class LLM,ExtDB,KB external;
  class WS volume;

  style Clients fill:#f0f5ff,stroke:#adc6ff,stroke-width:1px,color:#1f1f1f;
  style Runtime fill:#fff7e6,stroke:#ffd591,stroke-width:1px,color:#1f1f1f;
  style External fill:#f6ffed,stroke:#b7eb8f,stroke-width:1px,color:#1f1f1f;
  style Mounts fill:#ffffff,stroke:#d9d9d9,stroke-width:1px,color:#1f1f1f;
  style RightSide fill:transparent,stroke:transparent,color:transparent;
```

### 2.1 Docker Compose 服务说明

> compose 中包含 6 个 service，其中 `wunder_frontend` 仅用于构建前端静态资源并退出，常驻运行服务为 5 个。

| 服务 | 角色 | 说明 |
| --- | --- | --- |
| wunder_rust | 核心 API 服务 | Rust + Axum，对外暴露 `/wunder`、`/a2a` 与管理端接口；同时挂载管理端静态页面。 |
| sandbox | 沙盒执行服务 | 同一 `wunder-server` 二进制以 `sandbox` 模式启动，提供工具执行隔离与资源限制。 |
| wunder-mcp | MCP 服务 | Python FastMCP 进程，提供数据库/知识库等 MCP 工具。 |
| postgres | 主存储 | 生产默认使用 PostgreSQL，SQLite 仅用于测试。 |
| wunder_nginx | 用户前端 | 仅提供用户侧前端构建后的静态资源访问入口。 |
| wunder_frontend | 构建任务 | 只负责 `npm install && npm run build`，构建后退出。 |

## 3. 逻辑架构（Rust 内部）

```mermaid
flowchart TB
  API[API 路由层 /wunder /a2a /admin] --> Orchestrator[调度引擎 Orchestrator]
  Orchestrator --> Prompt[Prompt/上下文构建]
  Orchestrator --> LLM[LLM 适配层]
  Orchestrator --> Tools[工具执行层]
  Orchestrator --> Storage[存储层]
  Orchestrator --> Monitor[监控/事件流]

  Tools --> Builtin[内置工具]
  Tools --> MCPTools[MCP 工具]
  Tools --> Skills[Skills]
  Tools --> KBTool[知识库工具]
  Tools --> UserTools[自建/共享工具]
  Builtin --> Sandbox
```

### 3.1 核心模块职责

- API 接入层：统一鉴权、参数校验与路由，输出 SSE 与非流式响应。
- 调度引擎：会话锁、上下文管理、工具编排与异常恢复。
- 能力服务：模型适配、工具执行、知识库与向量检索、用户工具与共享策略。
- 存储与监控：会话历史、工具日志、运行态监控与配额状态。
- 沙盒执行：高风险指令隔离与资源限制。
- 运维评估：压测、评估与性能采样。
- 语言服务：提供工作区语义索引与诊断能力。

## 4. 请求与事件流程

```mermaid
sequenceDiagram
  participant U as 调用方
  participant API as API 层
  participant O as Orchestrator
  participant L as LLM
  participant T as 工具层
  participant S as Storage

  U->>API: POST /wunder (user_id, question, stream)
  API->>O: 构建请求上下文
  O->>S: 获取会话锁/历史/配额
  O->>L: 模型调用（可流式）
  L-->>O: 输出/工具调用意图
  alt 有工具调用
    O->>T: 执行工具（内置/MCP/Skills/知识库/用户工具）
    T-->>O: 返回工具结果
    O->>S: 记录工具日志/监控事件
  end
  O-->>U: SSE 事件 + 最终回答
  O->>S: 写入对话与监控数据
```

- 事件流会记录 `tool_call`、`tool_result`、`final`、`token_usage`、`context_usage` 等事件。
- `context_usage` 统计的是上下文占用量，而非计费 token 消耗。

## 5. 功能组件说明

### 5.1 调度与上下文管理

- Orchestrator 统一处理对话轮次、工具选择、结果合并与异常控制。
- 上下文压缩：基于 token 预算触发摘要生成，保证长对话稳定。
- 长期记忆：会话结束后写入 MemoryStore，供后续检索与召回。

### 5.2 工具体系

- 内置工具：文件读写、目录列出、搜索与替换、命令执行、ptc、LSP 诊断等。
- MCP 工具：来自配置的外部工具清单，以 `server@tool` 方式调用。
- Skills：以结构化流程描述输入输出与执行入口，作为可复用流程工具。
- 知识库工具：基于本地文档型知识库或外部检索服务，作为检索型工具调用。
- 向量知识库：通过嵌入模型与 Weaviate 检索，文档切片与索引由管理端/用户端接口维护。
- 自建/共享工具：用户级工具绑定与共享策略，按 `user_id@tool` 进行隔离。

### 5.3 沙盒执行

- 高风险工具（命令、ptc）在 `sandbox` 服务内执行，避免污染主服务进程。
- 沙盒支持 allow/deny 路径与命令策略，映射用户工作区到容器内目录。
- 可配置资源限制、超时、网络策略与只读根文件系统。

### 5.4 存储与状态

- PostgreSQL 为默认存储，SQLite 仅用于测试或轻量场景。
- 存储内容包括：会话与消息记录、工具/产物日志、监控事件、额度与用户数据。
- 会话锁按 `user_id + agent_id` 维度限制并发，支持同用户多智能体并行；会话记录保留 `agent_id` 与工具覆盖信息，便于恢复上下文与工具集。

### 5.5 MCP 服务

- MCP 服务为独立 FastMCP 进程，读取配置生成工具清单。
- 当前内置数据库查询与知识库检索能力，可扩展更多工具。

### 5.6 智能体广场与卡片

- 智能体配置持久化存储，包含名称、描述、系统提示词、工具集、共享与图标信息。
- 用户侧通过 `/wunder/agents`、`/wunder/agents/shared` 获取卡片数据，`/wunder/agents/running` 汇总运行中智能体。
- 访问控制维护允许/禁用列表，确保共享智能体按策略可见。

### 5.7 多智能体并行与会话隔离

- 调度层按 `user_id + agent_id` 维度加锁，保证同一智能体串行执行。
- 工作区按用户与智能体派生隔离，避免文件与状态互相污染。
- 会话恢复按 `agent_id` 维度归档，支持按智能体继续对话与工具设置继承。

### 5.8 向量知识库

- 向量知识库区分共享库与用户私有库，元数据与原文分离存储。
- 切片通过嵌入模型写入 Weaviate，检索返回相关切片与原文片段。
- 管理端与用户端提供文档上传、切片编辑与重建索引接口，检索由知识库工具统一触发。

```mermaid
flowchart LR
  Upload[上传文档] --> Parse[doc2md 解析]
  Parse --> Chunk[切片与元数据]
  Chunk --> Embed[嵌入模型]
  Embed --> VectorDB[向量数据库]
  Query[检索请求] --> EmbedQ[嵌入查询]
  EmbedQ --> VectorDB --> Hits[切片命中]
  Hits --> Assemble[生成检索结果]
```

### 5.9 前端与管理端

- 用户侧前端：Vue3 实现，支持浅色/深色主题与功能广场。
- 管理端：轻量静态页面，集成监控、配置、评估等入口。
- Rust 服务挂载管理端静态资源；用户侧前端由 nginx 提供。

## 6. 配置与治理要点

- 安全与权限：API Key、工具白名单/黑名单、命令与路径策略协同控制。
- 模型与嵌入：LLM 与 embedding 模型分离配置，支持不同调用模式与上下文预算。
- 工具治理：内置工具、MCP、Skills、知识库等统一纳入权限与可用性管理。
- 知识库策略：字面/向量两类检索并行，支持 top_k 与阈值等召回策略。
- 向量数据库：连接、超时与批量策略影响索引与检索吞吐。
- 运行与监控：并发上限、事件保留与日志级别确保可观测与稳定性。
- 沙盒策略：网络隔离、只读根与资源上限控制执行风险。

## 7. 扩展与演进方向

- 新模型：配置 OpenAI 兼容的 LLM endpoint 与模型参数即可接入。
- 新工具：扩展内置工具、接入 MCP 服务或新增 Skills 流程。
- 新知识库：通过 MCP、文档型或向量型知识库扩展检索能力。
- 运维体系：扩展评估用例、吞吐压测与性能采样维度。
