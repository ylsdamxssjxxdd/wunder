# wunder 系统介绍

## 1. 一页概览
wunder 是一个“智能体路由器”，对开发者而言一切是接口（API/配置/工具）；对大模型而言一切皆工具（可调用、可组合、可治理）。系统以 FastAPI 暴露统一入口 `/wunder`，同时支持流式 SSE 与非流式调用，能够将 LLM、MCP、Skills、知识库与自建/共享工具编排为可复用的智能体执行链路。
系统同时内置自托管 MCP 服务 `/wunder/mcp`，外部调用方可直接通过 MCP 协议提交任务并获取最终回复，管理端 MCP 列表中默认禁用该服务。

它的核心价值是：
- 统一入口 + 强工具编排：把多模型、多工具、多技能整合到一个调度面。
- 多用户隔离 + 持久化工作区：支持多人并发与长期对话资产沉淀。
- 可观测 + 可管控：线程级监控、工具调用热力图、可取消任务。
- 长期记忆：按用户开启自动总结并注入系统提示词，以 `[长期记忆]` 标签+纯文本段落强化长期上下文，每条记忆附带“年月日时分”时间前缀。
- 语言可切换：前端设置语言后，系统提示词与接口返回消息同步切换中英文，支持语言以 `i18n.supported_languages` 配置为准。

## 2. 架构总览
### 2.1 系统组件关系图
```mermaid
flowchart LR
  Client[客户端/调试页] -->|/wunder| API[FastAPI API层]
  API --> Orchestrator[Orchestrator 调度引擎]
  Orchestrator --> Prompt[Prompt Builder]
  Orchestrator --> LLM[LLM 适配层]
  Orchestrator --> Tools[工具执行层]
  Tools --> Builtin[内置工具]
  Tools --> MCP[MCP 工具]
  Tools --> Skills[Skills 技能]
  Tools --> KB[知识库工具]
  Tools --> UserTools[自建/共享工具]
  Builtin -->|命令/ptc| Sandbox[共享沙盒服务]
  Orchestrator --> Monitor[线程监控]
  Orchestrator --> Storage[SQLite/工作区]
  Storage --> Workspaces[多用户工作区]
```

### 2.2 核心模块职责
- API 层（`app/api`）：统一入口 `/wunder`、工具/技能/知识库管理接口、工作区管理与监控接口。
- 服务层（`app/services`）：配置更新、MCP 探测、工具清单构建等复用逻辑，避免路由层重复实现。
- Orchestrator（`app/orchestrator`）：任务编排、工具选择与调用、上下文压缩、SSE 事件流输出。
- MCP 服务层（`app/mcp`）：对外暴露自托管 MCP 接口，提供 wunder 自身工具。
- Prompt Builder（`app/prompts` + `app/orchestrator/prompt_builder.py`）：构建系统提示词，注入工具协议/环境/技能信息。
- 工具层（`app/tools` + `app/skills` + `app/knowledge`）：内置工具、MCP 工具、Skills 与知识库检索工具统一执行。
- 监控层（`app/monitor`）：线程生命周期、状态事件、系统资源指标。
- 存储层（`app/storage/sqlite.py` + `app/memory`）：SQLite 持久化对话/工具/监控日志与长期记忆，工作区文件持久化。
- 基础设施（`app/core/http_client.py`）：复用 HTTP 连接池，降低模型与沙盒调用开销。

## 3. 运行流程（从请求到回复）
```mermaid
sequenceDiagram
  participant U as 用户/前端
  participant API as API层
  participant O as Orchestrator
  participant P as Prompt Builder
  participant L as LLM
  participant T as 工具执行层
  participant S as 存储/监控

  U->>API: POST /wunder (user_id, question, tool_names, stream)
  API->>O: 创建会话并注册线程
  O->>P: 构建系统提示词(含工具/技能/工作区信息)
  O->>L: 调用模型(可流式)
  L-->>O: 生成工具调用或答案
  O->>T: 执行工具(内置/MCP/Skills/知识库/自建)
  T-->>O: 工具结果
  O->>S: 写入对话/工具/监控记录
  O-->>U: SSE事件或最终回复
```

补充：当最终回复完成后，系统会将该会话加入长期记忆总结队列，按完成时间顺序逐条生成记忆摘要并落库；总结请求使用 `app/prompts/memory_summary.txt` 作为系统提示词，并将历史消息融合为单条用户内容，同时写入任务日志供历史队列追踪。

## 4. 工具体系（重点）
wunder 把所有能力统一抽象为“工具”，并通过提示词注入与工具协议驱动大模型调用。

### 4.1 工具类型与来源
| 工具类型 | 来源/存放 | 触发方式 | 共享/管控 | 适用场景 |
| --- | --- | --- | --- | --- |
| 内置工具 | `app/tools/catalog.py` + `app/tools/builtin.py` | 直接调用工具名 | 管理员配置启用 | 文件操作、命令执行、ptc 脚本 |
| MCP 工具 | `config/wunder.yaml` 基础配置 + `data/config/wunder.override.yaml` 覆盖 + `/wunder/admin/mcp` | 形如 `server@tool` | 管理员启用 + allow_tools | 连接外部服务/平台能力（含自托管 `wunder@run`） |
| Skills | `skills/`、`EVA_SKILLS/`、用户技能包 | 技能名 | 管理员/用户启用 | 固化流程/最佳实践 |
| 知识库 | `knowledge/` 或用户知识库 | 知识库名作为工具 | 管理员/用户配置 | 本地知识检索 |
| 自建工具 | `data/user_tools/<user_id>` | 形如 `user_id@tool` | 用户配置 | 个性化能力扩展 |
| 共享工具 | 来自其他用户的共享配置 | 形如 `owner_id@tool` | 共享标记 | 跨用户能力复用 |

### 4.2 工具调用机制
- 统一工具协议：EVA 风格 `<tool_call>{"name":"工具名","arguments":{...}}</tool_call>`。
- 工具注入策略：只有 `tool_names` 中显式选择的工具才会注入系统提示词，减少提示词膨胀。
- 内置工具支持英文别名（如 `read_file`、`write_file`），模型与接口可使用英文名触发调用。
- `a2ui` 为可选输出工具，显式勾选后会替换“最终回复”工具，用于输出 A2UI 消息并在调试面板渲染 UI。
- 允许列表：
  - 内置工具受 `config.tools.builtin.enabled` 管控。
- MCP 工具使用预先缓存的 `tool_specs`，不会在提示词构建时触发远端发现。
- MCP 工具调用超时由 `config.mcp.timeout_s` 统一控制，避免外部服务阻塞线程。
- Skills 仅注入已启用的技能元信息。
- 知识库按配置生成独立工具，未启用项不会注入工具清单。
- 自托管 MCP 工具 `wunder@run` 在内部执行时会剔除自身工具，并固定 `user_id = wunder`，避免递归调用。

### 4.3 知识库机制
- 知识库以 Markdown 文档为输入，按一级标题切分为“知识点”。
- 每个知识库是一把独立“工具”，输入 `query/limit` 返回结构化知识点列表。
- 先做文本候选筛选，再用检索专用模型重排序；解析失败时回退到词面匹配，保证可用性。
- 缓存知识库解析结果，减少重复 IO 与解析成本。

### 4.4 Skills 机制
- 每个技能包含 `SKILL.md`（YAML frontmatter 描述名称、输入结构等）。
- 技能执行入口支持 `run.py/skill.py/main.py`，统一 `run(payload)` 调用。
- 系统提示词会引导模型“先读 SKILL.md 再执行”，把技能当作“流程手册”。

### 4.5 自建/共享工具机制
自建/共享工具的核心是“配置即工具包 + 统一别名路由”，共享并不是复制工具实现，而是共享配置与可用清单。

**自建工具原理**
- 配置即工具包：每个用户在 `data/user_tools/<user_id>/config.json` 维护独立配置，包含 MCP 服务（含 cached `tool_specs`、`allow_tools`、`shared_tools`）、技能启用/共享、知识库列表（enabled/shared 标记）、`extra_prompt`。
- 读取与规范化：系统加载配置时会做清洗与约束（例如 `shared_tools` 必须是 `allow_tools` 子集、`skills.shared` 必须是 `skills.enabled` 子集），并对知识库目录做安全解析，避免路径越界。
- 别名注册：自建工具统一命名为 `user_id@tool`（MCP 为 `user_id@server@tool`），避免与内置/MCP/技能/知识库冲突。
- 注入与执行：`/wunder/tools` 会把自建工具合入工具清单，只有被选择的 `tool_names` 才注入提示词；执行阶段通过别名映射找到具体资源，仍受 allow_paths/deny_globs 的安全策略约束。

**共享工具原理（共享配置 + 别名路由）**
- 共享标记即白名单：MCP 通过 `shared_tools` 控制对外共享的工具；Skills 通过 `shared` 列表；知识库通过 `shared` 布尔值。
- 共享发现与缓存：系统扫描 `data/user_tools/*/config.json` 汇总共享载荷（带短 TTL 缓存），配置变更会刷新共享版本号以触发提示词缓存失效。
- 共享呈现方式：`/wunder/tools` 将共享工具单独列出并附带 `owner_id`，名称仍为 `owner_id@tool`；默认不注入提示词，需由用户显式勾选。
- 共享执行方式：编排时为共享工具建立 `alias -> (kind, owner_id, target)` 映射；执行时根据 `owner_id` 加载对方的 MCP 配置/技能目录/知识库目录完成调用，但不会共享对方的额外提示词或工作区。

### 4.6 系统管理工具核心流程（含自建/共享）
系统管理工具的核心目标是：统一配置入口、统一工具清单、统一提示词注入，并在执行阶段严格隔离与可控复用。

```mermaid
flowchart LR
  Config["配置入口(config/wunder.yaml + data/config/wunder.override.yaml + app/user_tools/store.py)"] --> Catalog["工具清单(/wunder/tools, app/services/tool_service.py)"]
  Catalog --> Orchestrator["编排与注入(app/orchestrator/engine.py + prompting.py)"]
  Orchestrator --> Exec["执行器(app/orchestrator/tool_executor.py)"]
  Exec --> Pool["工具池(app/tools + app/skills + app/knowledge + MCP/用户工具)"]
```

核心机制说明：
- 管理员通过 `/wunder/admin/*` 完成内置工具/MCP/技能/知识库的启用与配置，形成全局基线能力。
- 用户通过“自建工具”入口配置个人 MCP、上传技能包、维护个人知识库，并决定是否共享。
- 系统统一汇总工具清单到 `/wunder/tools`，再根据 `tool_names` 选择性注入提示词，避免不必要的上下文膨胀。
- 共享工具以 `owner_id@tool` 形式暴露，其他用户仅在选择后才可调用，确保隔离与可管控。

## 5. 智能体线程管理（会话生命周期）
### 5.1 线程并发规则
- 同一 `user_id` 同时只能有一个运行中的会话，请求冲突时返回 429。
- 并发互斥基于 SQLite `session_locks` 表，支持单机多进程的互斥与过期回收，并由心跳续租。
- 线程由 `SessionMonitor` 统一记录：状态、阶段、事件与资源统计。

### 5.2 线程状态机
```mermaid
stateDiagram-v2
  [*] --> running: 注册会话
  running --> cancelling: 请求取消
  cancelling --> cancelled: 中断完成
  running --> finished: 输出 final
  running --> error: 异常/超时
```

### 5.3 事件与监控
- 事件类型：`progress/llm_request/knowledge_request/llm_output_delta/llm_stream_retry/llm_output/tool_call/tool_result/a2ui/token_usage/final/error`（持久化可按 `observability.monitor_drop_event_types` 过滤）。
- 监控数据落库 SQLite，可在 `/wunder/admin/monitor` 查询实时/历史线程。
- 监控事件会按 `observability.monitor_event_limit` 保留最近 N 条，<= 0 表示不限制，并按 `monitor_payload_max_chars` 裁剪超长字段。
- 断开 SSE 不会强制终止任务，任务继续执行并写入监控与历史。
- SSE 队列满时事件会落库到 `stream_events`，流式通道会回放补齐以避免丢失。

## 6. 工作区与数据持久化
- 工作区：`data/workspaces/<user_id>/files`，用户隔离且持久化。
- 工作区管理接口支持内容读取、搜索、批量移动/复制与分页排序，前端以树形视图交互。
- 对话历史、工具日志、产物索引、监控、会话锁与溢出事件统一写入 SQLite（`data/wunder.db`）。
- 长期记忆记录写入 `memory_records`，按用户开关注入系统提示词（带 `[长期记忆]` 标签与时间前缀），单用户最多保留 30 条。
- 记忆任务日志写入 `memory_task_logs`，按会话覆盖保留最新一次总结结果与请求详情。
- 历史压缩：接近上下文上限时自动压缩历史，生成摘要并保留关键消息，详见 6.1。

### 6.1 模型上下文压缩原理
上下文压缩的目标是“保留最新可工作信息 + 提供可交接摘要 + 严格控制上下文预算”，在不中断会话的前提下降低长对话的 token 压力。

**触发条件（双阈值）**
- 历史 usage 触发：会话累计历史 token 达到 `max_context * history_compaction_ratio`（默认 0.8）。
- 上下文溢出触发：当前消息总 token 超过安全预算 `max_context * 0.9`，并扣除输出预留与安全冗余。

**压缩输入如何构建**
- 保留当前系统提示词与历史消息，但将“最后一条 user 消息”替换为压缩指令（`compact_prompt.txt`）。
- 摘要输入会进行裁剪：单条消息最大 token 限制，思考链（reasoning）会被移除。
- 多模态图片按固定 token 估算，base64 会被占位符替换，避免误触发压缩。

**上下文压缩流程图**
```mermaid
flowchart TD
  A["进入压缩检查"] --> B["读取配置<br/>max_context/history_compaction_ratio/max_output"]
  B --> C["计算安全预算 limit<br/>min(max_context*0.9, max_context-输出预留-安全冗余)"]
  C --> D["读取会话历史 usage"]
  D --> E["估算当前 messages token"]
  E --> F{"触发压缩？<br/>usage >= max_context*ratio<br/>或 tokens > limit"}
  F -- "否" --> Z["跳过压缩，继续模型调用"]
  F -- "是" --> G["筛选候选消息<br/>剔除 system 与历史摘要"]
  G --> H{"候选为空？"}
  H -- "是" --> Z
  H -- "否" --> I["定位尾部交互块<br/>避免截断最新轮次"]
  I --> J["按预算保留尾部<br/>keep_recent_tokens≈2000"]
  J --> K{"尾部已覆盖且<br/>非历史强制？"}
  K -- "是" --> Z
  K -- "否" --> L["构建摘要输入<br/>替换最后 user 为压缩指令<br/>保留系统提示词"]
  L --> M["摘要输入裁剪<br/>移除 reasoning<br/>限制单条长度/适配 limit"]
  M --> N["计算压缩边界<br/>compacted_until"]
  N --> O["调用模型生成摘要<br/>max_output<=1024"]
  O --> P{"摘要成功？"}
  P -- "是" --> Q["写入摘要系统消息<br/>标记 compaction_meta"]
  P -- "否" --> R["写入占位摘要<br/>继续裁剪历史"]
  Q --> S["重建上下文<br/>系统提示词+摘要+近期消息"]
  R --> S
  S --> T["极端超限时<br/>裁剪 tool_response 内容"]
  T --> U["按策略重置 usage<br/>zero/current/keep"]
  U --> V["发送 compaction 事件"]
  V --> Z
```

**保留策略（避免截断最新轮次）**
- 计算“尾部交互块”（最近一轮 user/assistant 交互）并优先保留。
- 保留最近约 2000 token 的尾部消息；若历史 usage 达阈值，即使尾部未超限也会强制生成摘要，至少保留最后一条消息。

**摘要生成与落库**
- 由同一模型生成“交接摘要”，并插入为系统消息，带 `[上下文摘要]` 前缀。
- 摘要条目会记录覆盖时间边界，便于后续过滤早期历史。
- 生成摘要的请求与结果会写入调试请求日志，便于回溯。
- 摘要采用结构化模板输出，并注入产物索引，避免文件/命令轨迹被压缩丢失。

**兜底与恢复**
- 若摘要生成失败，会写入占位摘要并继续裁剪历史，确保请求可继续完成。
- 极端超限时会优先裁剪工具观察结果（tool_response），每条保留最少 token，保证主对话不被挤占。

**历史 usage 重置**
- 压缩后按策略重置累计历史 token（`zero/current/keep`），避免重复触发。

## 7. 安全与效率设计
- 接口鉴权：`/wunder` 与 `/wunder/mcp` 需携带 API Key，请在 `config/wunder.yaml` 的 `security.api_key` 配置。
- 工具权限控制：`security.allow_commands/allow_paths/deny_globs` 白名单策略。
- 沙盒执行：`执行命令` 与 `ptc` 可走共享沙盒服务，限制网络/只读根文件系统。
- Prompt 缓存：根据用户、工作区树版本、工具列表、用户工具版本进行缓存。
- 工作区树缓存：减少重复目录遍历。
- 模型请求降载：工具与技能仅在需要时注入，降低提示词长度与调用成本。
- HTTP 连接池复用：统一 LLM/MCP/沙盒请求客户端，减少连接建立开销。
- 启动优化：MCP 服务、监控与调度器采用惰性初始化，降低进程启动耗时，首次触达相关能力可能有冷启动延迟。
- 轻量入口：推荐使用 `uvicorn app.asgi:app` 秒起，`WUNDER_LAZY_WARMUP_S` 控制后台预热延迟（秒，负数/关闭值表示禁用预热）。

## 8. 运维与管理入口
- `/wunder`：统一调用入口（流式/非流式）。
- `/wunder/tools`：工具清单（内置/MCP/知识库/技能/自建/共享）。
- `/wunder/i18n`：语言配置（默认语言、支持语言、别名映射）。
- `/wunder/admin/*`：模型/MCP/技能/工具/监控/用户管理（内置工具接口返回启用状态与输入结构）。
- `/wunder/admin/memory/*`：长期记忆管理（用户开关、记录列表、清空/删除、队列状态与详情）。
- `/wunder/workspace/*`：临时工作区文件管理（内容读取、搜索、批量操作）。
- `/wunder/web`：调试前端，包含系统介绍页面。
- `/wunder/ppt`：系统介绍 PPT 静态资源（`docs/ppt`，每页拆分为 `slides/*.js`，顺序由 `slides/manifest.js` 维护），供嵌入与全屏展示。
- `/wunder/ppt-en`：系统介绍 PPT 英文版静态资源（`docs/ppt-en`，每页拆分为 `slides/*.js`，顺序由 `slides/manifest.js` 维护）。

## 9. 关键目录结构（便于定位）
```
app/                 # API与核心逻辑
  asgi.py             # 轻量 ASGI 启动入口（惰性加载）
  api/               # 入口与管理接口
  services/          # 配置/工具/MCP 复用服务
  orchestrator/      # 编排与提示词构建
  tools/             # 内置工具 + MCP 适配
  skills/            # Skills 加载与执行
  knowledge/         # 知识库解析与检索
  memory/            # 工作区与历史管理
  monitor/           # 线程监控与状态
  storage/           # SQLite 持久化
config/              # 基础配置（wunder.yaml）
data/config/         # 管理端持久化覆盖（wunder.override.yaml）
knowledge/           # 公共知识库
EVA_SKILLS/          # 技能包目录
skills/              # 内置技能目录
web/                 # 调试前端
docs/ppt/            # 系统介绍 PPT（入口 index.html）
docs/ppt/slides/     # 单页模块（每页一个 js，manifest.js 维护顺序）
docs/ppt-en/         # 系统介绍 PPT 英文版（入口 index.html）
docs/ppt-en/slides/  # 单页模块（每页一个 js，manifest.js 维护顺序）
```

---
如需更深层的技术细节，可参见：`docs/设计方案.md` 与 `docs/API文档.md`。
