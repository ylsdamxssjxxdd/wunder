# wunder 系统介绍（代码对齐版）

本文档面向管理者和系统负责人，基于当前代码说明 wunder 的定位、能力边界、运行机制和治理方式。

## 1. 一页概览

wunder 是一个智能体调度平台。它把模型调用、工具调用、知识检索、会话管理和治理能力放到同一平台中，形成可扩展、可观测、可管控的统一执行底座。

一句话概括：

- 对开发者，能力统一为接口。
- 对模型，能力统一为工具。
- 对组织，能力统一为可治理资产。

## 2. 当前版本核心能力

- 统一入口。wunder 系列接口承接普通调用、聊天会话、管理操作、渠道接入、网关控制面。
- Single-port access is supported in docker compose: expose only `18001` publicly and forward `/wunder`, `/a2a`, and `/.well-known/agent-card.json` to the internal backend.
- 双流式通道。默认 WebSocket，SSE 兜底，并支持事件断点恢复。
- 用户世界通信。新增用户↔用户实时通信域（联系人/会话/消息/已读），并支持用户容器文件区、@路径附件发送与下载。
- 用户侧交互壳重构。用户前端改为 HuLa 风格三栏聊天布局，统一承载消息/用户/群聊/智能体/工具/文件/更多设置，并在右侧提供沙盒、时间线、设置扩展区。
- 主线程和队列。按 user_id 和 agent_id 维护主会话，忙时进入任务队列。
- 多通信入口。支持用户侧请求、外部 webhook 渠道、网关节点接入三类入口。
- 多工具编排。内置工具、MCP、A2A、Skills、知识库、用户自建和共享工具统一编排。
- 多运行形态统一。`wunder-server`、`wunder-cli`、`wunder-desktop` 共用同一套 Rust 核心编排与工具系统。
- 提示词治理模块化。系统提示词按分段文件组织（role/engineering/tools_protocol/skills_protocol/历史记忆/extra），支持多套模板包（`prompt_templates.active`，默认包只读，建议新建包后编辑）；运行环境段按 `server.mode` 区分 server 与 cli/desktop。
- 双语提示词目录。提示词维护在 `prompts/zh` 与 `prompts/en`；英文模式强制优先英文工具别名，降低跨语言调用歧义。
- 蜂群协作能力。保留 `hive_id` 作用域模型，当前产品收敛为单蜂巢（`default`）稳定运行。
- 飞书长连接。对 active 且凭证完整的飞书账号自动维持 WebSocket 长连接，收到消息后进入 ChannelHub 主链路。
- 微信渠道回调与直连出站。支持企业微信 `/wunder/channel/wechat/webhook` 与微信公众号 `/wunder/channel/wechat_mp/webhook`（GET URL 验证 + POST 消息回调），并可用官方 API 直接回包。
- 管理端运行态可视化。渠道监控页可查看 `runtime.feishu_long_connection` 状态和绑定数，便于排查接入问题。
- 多模态渠道。支持语音转写、图片识别、地理描述、语音回包。
- 前端工程化。用户侧前端已升级为 TypeScript 实现，当前交付门槛为 `npm run typecheck` 与 `npm run build:check`。
- 组织治理。支持组织树、角色权限、配额和访问控制。
- 评估运维。内置监控、吞吐压测、性能采样、能力评估。

## 3. 系统结构

### 3.1 服务层结构

#### 系统组件关系图

```mermaid
flowchart LR
  USER[用户前端 frontend] --> API[Axum API]
  ADMIN[管理端 web] --> API
  CH[渠道 Webhook] --> HUB[ChannelHub]
  GW[Gateway Client] --> GWHUB[GatewayHub]

  API --> AR[AgentRuntime]
  HUB --> AR
  AR --> ORCH[Orchestrator]
  ORCH --> TOOL[Tooling]
  ORCH --> MON[MonitorState]
  ORCH --> DB[(Postgres)]
  ORCH --> WV[(Weaviate)]
  ORCH --> WS[(Workspace)]

  TOOL --> MCP[MCP或A2A或Skills]
  TOOL --> SBX[wunder-sandbox]
  TOOL --> KB[知识库检索]
  ORCH --> LLM[LLM API]
```

- wunder-server。主服务，承接 API 路由和调度执行。
- sandbox。沙盒服务，承接高风险执行任务。
- postgres。关系数据主库。
- weaviate。向量检索后端。
- frontend。用户侧前端（Vue3 + TypeScript）。
- web。管理端前端（治理与调试视角）。

### 3.2 代码层结构

#### 代码层协作图

```mermaid
flowchart TB
  API[api] --> SRV[services]
  API --> CHN[channels]
  API --> GATE[gateway]
  SRV --> ORC[orchestrator]
  ORC --> STG[storage]
  ORC --> OPS[ops monitor]
  ORC --> LSP[lsp]
  ORC --> SBOX[wunder-sandbox]
```

- api 层。路由和协议适配。
- orchestrator 层。模型和工具调度核心。
- services 层。用户、会话、工具、知识、定时任务、工作区等服务。
- channels 层。外部消息渠道接入和回包。
- gateway 层。控制平面连接管理。
- storage 层。数据库读写抽象。
- ops 层。观测和评估能力。

## 4. 三条主业务链路

### 4.1 用户对话链路

#### 用户对话时序图

```mermaid
sequenceDiagram
  participant U as 用户
  participant API as API
  participant AR as AgentRuntime
  participant O as Orchestrator
  participant T as Tools
  participant S as Storage

  U->>API: /wunder 请求
  API->>AR: submit_user_request
  alt 主线程繁忙且队列开启
    AR->>S: 写入 agent_tasks
    AR-->>U: queued 响应
  else 直接执行
    AR->>O: execute_stream
    O->>S: 加锁并读取历史
    loop 模型轮次
      O->>O: 调用 LLM
      alt 触发工具
        O->>T: execute
        T-->>O: result
      end
      O->>S: 写入事件和日志
    end
    O-->>U: WS 流式事件，SSE 兜底
  end
```

1. 客户端发起请求。
2. 系统解析用户身份并绑定会话。
3. AgentRuntime 判断是否需要排队。
4. Orchestrator 执行模型和工具循环。
5. 事件流实时输出并持久化。
6. 最终结果和会话状态回写数据库。

### 4.2 渠道消息链路

#### 渠道处理流程图

```mermaid
flowchart LR
  IN[渠道入站消息] --> VERIFY[签名与账号校验]
  VERIFY --> MAP[绑定用户与会话]
  MAP --> MM[媒体预处理]
  MM --> RUN[调度执行]
  RUN --> OUT[channel_outbox]
  OUT --> RETRY[异步重试投递]
```

1. 外部渠道 webhook 接入。
2. 系统校验账号和签名。
3. 根据绑定策略映射用户和会话。
4. 多模态消息预处理。
5. 调度引擎生成回复。
6. 出站消息进入 outbox 并异步投递。

### 4.3 网关控制面链路

#### 网关控制流程图

```mermaid
sequenceDiagram
  participant C as node或operator
  participant WS as /wunder/gateway/ws
  participant H as GatewayHub
  participant D as DB

  C->>WS: connect
  WS->>H: register_client
  H->>D: upsert gateway_clients
  H->>D: upsert gateway_nodes
  WS-->>C: welcome与presence
  C->>WS: invoke response
  WS->>H: route and broadcast
  H->>D: 更新连接状态
```

1. operator、node 或 channel 建立网关连接。
2. 网关完成握手并登记连接状态。
3. 管理端可查询 presence 并下发 node invoke。
4. 响应和状态事件回写控制平面表。

### 4.4 蜂群协作链路（单蜂巢模式）

#### 蜂群协作流程图

```mermaid
flowchart LR
  U[用户会话请求] --> O[Orchestrator]
  O --> S[agent_swarm tool]
  S --> R[创建 TeamRun]
  R --> T[派发 TeamTask]
  T --> A[子智能体执行]
  A --> M[结果归并]
  M --> F[最终回复]
  M --> P[SwarmPanel 进度展示]
```

1. 会话内触发蜂群能力后，系统在当前会话上下文中创建 TeamRun。
2. TeamRun 拆解为多个 TeamTask 由子智能体并行执行，再由母任务归并结果。
3. 聊天页通过标题栏图标打开 `SwarmPanel`，实时展示 TeamRun/TeamTask 进度。
4. `agent_swarm` 与 TeamRun 接口保留 `hive_id` 作用域参数，默认取当前会话蜂巢。
5. 当前版本固定单蜂巢（`default`）：用户侧不再提供蜂巢切换/新增入口，应用协作统一在同一蜂巢内完成。

### 4.5 用户世界链路（用户↔用户）

#### 用户世界通信流程图

```mermaid
sequenceDiagram
  participant A as 用户A
  participant API as /wunder/user_world/*
  participant UW as UserWorldService
  participant DB as user_world_* tables
  participant WS as /wunder/user_world/ws
  participant B as 用户B/群成员

  A->>API: 获取聊天/用户/群聊列表
  A->>API: 创建或进入会话（direct/group）
  A->>API: 发送消息
  API->>UW: send_message
  UW->>DB: 写消息/更新所有成员未读/写事件
  UW-->>WS: 广播 uw.message
  WS-->>A: event(uw.message)
  WS-->>B: event(uw.message)
  B->>API: 已读回写
  API->>UW: mark_read
  UW->>DB: 更新 read + 事件
  WS-->>A: event(uw.read)
```

1. 用户侧通过 `/wunder/user_world/contacts`、`/groups` 与 `/conversations` 拉取“用户/群聊/最近聊天”数据。
2. 发送消息落库到 `user_world_messages`，并更新会话摘要、所有成员未读计数与 `user_world_events`。
3. WebSocket 通道实时推送 `uw.message/uw.read`；断线时可通过 SSE `events` 以 `after_event_id` 续传补偿。
4. 用户容器文件落在用户工作区 `user-world/` 目录，@路径会渲染为文件卡片并支持下载，删除后前端标记为已移除。

## 5. 并发与隔离策略

### 5.1 隔离

- 会话级隔离。session_id 维度互斥。
- 主线程隔离。user_id 加 agent_id 维度维护主会话。
- 工作区隔离。用户和容器作用域共同隔离文件空间。
- 身份隔离。虚拟用户与注册用户均可调用调度链路，治理策略不同。

### 5.2 排队与恢复

#### 排队与会话状态图

```mermaid
stateDiagram-v2
  [*] --> idle
  idle --> busy: 收到执行请求
  busy --> waiting: 进入排队或等待用户输入
  waiting --> busy: 继续执行
  busy --> cancelling: 用户取消
  waiting --> cancelling: 用户取消
  cancelling --> cancelled
  busy --> finished: 产出 final
  busy --> error: 异常
```

- 忙会话请求可进入 agent_tasks，由后台消费。
- 流式事件写入 stream_events，断线可恢复。

### 5.3 轮次统计

- 用户轮次按输入消息计数。
- 模型轮次按模型动作计数。
- token 相关统计用于上下文占用评估，不等同计费总消耗。

## 6. 数据资产

系统将会话过程资产化，主要沉淀内容包括：

- 会话元数据和消息历史
- 工具调用和产物日志
- 监控快照和流式事件
- 主线程和排队任务状态
- 定时任务定义与运行记录
- 渠道接入、回包和媒体索引
- 网关连接和节点令牌
- 用户、组织、权限、智能体配置
- 评估记录和向量文档元数据

## 7. 治理机制

### 7.1 权限治理

- 管理接口支持 api key 和管理员 token。
- 用户接口通过 token 鉴权。
- 外部系统嵌入可通过 `security.external_auth_key` 调用 `/wunder/auth/external/*` 签发一次性登录码（或 Token）实现免登录接入。
- 工具和智能体访问可按用户维度配置白名单和屏蔽列表。

### 7.2 安全治理

- 命令和路径执行受白名单与 deny 规则约束。
- 高风险执行可下沉到 sandbox。
- 渠道接入支持 token 或签名校验。
- 网关支持 origin 约束和受信代理策略。

### 7.3 成本治理

- 支持用户配额和组织层级治理。
- 管理员可在管理端查看用量并调优策略。

## 8. 可观测性与运维能力

### 8.1 上下文压缩流程图

```mermaid
flowchart LR
  A[读取上下文与预算] --> B{超过阈值?}
  B -- 否 --> K[保持原上下文]
  B -- 是 --> C[构建压缩输入]
  C --> D[裁剪超长字段]
  D --> E[调用摘要模型]
  E --> F{摘要成功?}
  F -- 是 --> G[写入 compaction 结果]
  F -- 否 --> H[写入占位摘要]
  G --> I[重建上下文并继续执行]
  H --> I
```

- MonitorState 维护会话状态机和事件日志。
- 支持会话级取消、上下文压缩、异常追踪。
- 内置吞吐压测、性能采样、能力评估模块。
- 支持流式协议握手信息和慢客户端告警。

## 9. 运行入口与运行形态

### 9.1 用户侧入口

- 用户前端负责聊天、会话、工作区、应用广场、渠道账号配置（新增/编辑/删除）等能力。
- 桌面端与用户前端保持同构页面结构，复用 `UserLayout`、聊天与设置体系。

### 9.2 管理端入口

- 管理端负责模型配置、工具管理、监控、评估、组织用户治理、渠道运行监控、网关治理。

### 9.3 对外接口族

- wunder 核心接口
- wunder chat 会话接口
- wunder admin 管理接口
- wunder ws 和 wunder chat ws
- wunder gateway ws
- a2a 标准接口
- wunder mcp 接口

### 9.4 运行形态（server / cli / desktop）

- `wunder-server`：面向多租户和前后端协同，提供 `/wunder`、WebSocket、SSE、管理接口与治理能力。
- docker compose（x86/arm）默认可直接 `up`：`wunder-server`、`wunder-sandbox`、`extra-mcp` 复用同名本地镜像（已存在则优先复用，不存在再自动构建），并避免远端拉取同名镜像。
- docker compose 默认使用两个命名卷：`wunder_workspaces`（`/workspaces`，用户工作区）与 `wunder_logs`（PostgreSQL/Weaviate 数据目录）；`/wunder/temp_dir/*` 默认落在本地 `./temp_dir`（容器内 `/app/temp_dir`，可用 `WUNDER_TEMP_DIR_ROOT` 覆盖）；其余运行态可写配置保留在仓库本地 `data/`。构建/依赖缓存（`target/`、`.cargo/`、`frontend/node_modules/`）保持写入仓库目录便于管理。
- server 基础配置优先读取 `config/wunder.yaml`，缺失时自动回退 `config/wunder-example.yaml`；`.env` 为可选，仅在需要覆盖默认参数时使用。
- `wunder-cli`：面向单用户本地使用，持久化目录为 `WUNDER_TEMP/`，工作目录为启动目录；支持审批模式（`approval_mode`）与 codex 风格 TUI（`/approvals`、`/diff`、`/review`、`/mention`、`/mcp`、`/skills`、`/apps`、`/ps`、`/clean`、`/fork`、`/rename`、`/compact`、`/debug-config`、`/statusline`）。
- CLI 默认优先读取 `config/wunder.yaml`；若仓库外运行配置缺失，会自动生成 `WUNDER_TEMP/config/wunder.base.yaml` 兜底。
- CLI 支持 `resume` 会话恢复、JSONL 事件输出与 codex 风格 TUI，交互命令覆盖会话管理、配置调试、连接器治理与后台控制。
- CLI 具备会话分叉/压缩能力（`/fork`、`/rename`、`/compact`），并提供 `/debug-config` 输出配置来源层级；TUI 底部状态栏可通过 `/statusline` 自定义与持久化。
- 输入区支持 Windows 粘贴 burst 防误提交与右键粘贴；流式输出支持自适应背压，长输出场景下保持界面响应。
- CLI 输出支持中/英双语（由 `--lang`/`--language` 与 i18n 解析器统一决策），覆盖操作指引、Slash 命令提示、审批提示、常用日志与 TUI 状态文本。
- `wunder-desktop`：默认采用“**Tauri 桌面窗口 + 内置本地桥接服务**”，并提供可选 Electron 壳（AppImage 友好）；本地桥接默认 `127.0.0.1:27653`（支持 `--port 0`）。
- Desktop 启动时提供 `GET /config.json` 与 `GET /wunder/desktop/bootstrap` 引导接口，Tauri 同时暴露 `desktop_runtime_info` command。
- Desktop 主窗口支持无边框模式（`decorations=false`），并注入 `window.wunderDesktop` 窗口桥接（最小化/最大化切换/关闭/拖拽/最大化状态查询/调试工具），前端可统一实现自定义标题栏与窗口按钮样式。
- Desktop 持久化目录默认程序同级 `WUNDER_TEMPD/`；Electron 版本改为 `userData/WUNDER_TEMPD` 并通过 `--temp-root` 注入；工作目录默认 `WUNDER_WORK/`，Electron 版本通过 `--workspace` 指向 `userData/WUNDER_WORK`，并支持容器工作目录映射。
- Desktop 设置页支持 `tool_call/function_call` 切换与 MCP/Skills 管理；模型配置会持久化到 `desktop.settings.json` 并即时生效；默认轻量运行（关闭 channels/gateway/agent_queue/cron）。
- 启用 `remote_gateway` 后，desktop 仅需配置服务端地址即可切换远端 `/wunder`；点击接入后跳转常规注册/登录流程，远端不可用时自动回退本地并保留 `remote_error` 诊断信息。

### 9.5 渠道隔离补充

- 用户侧渠道账号在默认绑定时可写入 agent_id，用于将渠道路由到指定智能体，避免跨应用共享。

## 10. 结论

wunder 已从单一对话服务演进为多入口、多工具、多治理能力的智能体调度底座。当前架构重点在于三件事：

- 保持主链路稳定。
- 保持扩展方式统一。
- 保持治理能力可落地。

后续演进应继续坚持接口化扩展、可观测优先和运行安全优先。
