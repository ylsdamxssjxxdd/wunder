# 定时任务落地方案（Wunder）

> 目标：在 Wunder 内置“定时任务”工具（参考 EVA 的 schedule_task 设计与提示词），支持任务持久化、执行回传、触发智能体续跑，并在用户侧前端提供可视化管理入口。

---

## 1. 参考与对齐

### 1.1 EVA 的工具设计（schedule_task）
- **工具名**：`schedule_task`
- **schema（关键字段）**：
  - `action`: add/update/remove/enable/disable/get/list/run
  - `job`:
    - `job_id`, `name`
    - `schedule`: `{ kind: at|every|cron, at, every_ms, cron, tz }`
    - `session`: `main|isolated`
    - `payload`: `{ message }`
    - `enabled`, `delete_after_run`, `dedupe_key`
- **提示词位置**：工程师提示词中明确“可以使用 schedule_task 设置提醒或周期任务”。

### 1.2 EVA 的调度器实现要点（SchedulerService）
- 单定时器驱动（下一次触发）
- 任务持久化：`jobs.json`，运行记录 `runs/<jobId>.jsonl`
- 重启恢复：加载 jobs 并重新计算 next_run

> Wunder 需要保持 schema 与提示词兼容，但实现方式改为 Rust + Postgres/SQLite。

---

## 2. 需求拆解（本次目标）

1) **内置工具**：新增“定时任务”工具（名称建议 `schedule_task`），工具提示词与 EVA 对齐。  
2) **记住智能体会话**：任务创建时记录 `user_id + session_id + agent_id`。  
3) **执行成功回传 + 续跑**：
   - 任务执行完成后，将结果写回该智能体会话。
   - 若智能体不空闲，则等待空闲后再触发运行。
4) **前端入口**：用户侧“工具管理”按钮后新增“定时任务”按钮，打开后可查看/操作任务。

---

## 3. 设计原则

- **接口兼容优先**：工具 schema 与 EVA 保持一致，减少提示词迁移成本。
- **持久化优先**：任务与运行记录写数据库（Postgres；SQLite 仅测试）。
- **低资源占用**：单定时器 + 任务索引 + 轻量查询。
- **可观测**：状态/错误/执行耗时可追踪。
- **安全**：任务仅作用于所属 user_id/agent_id，不越权。
- **不中断**：系统重启后恢复 next_run。

---

## 4. 数据模型（建议）

### 4.1 CronJob（持久化）
- `job_id` (PK)
- `user_id`
- `session_id`
- `agent_id`
- `name`
- `enabled`
- `delete_after_run`
- `schedule_kind` (`at|every|cron`)
- `schedule_at` (RFC3339)
- `schedule_every_ms` (i64)
- `schedule_cron` (string)
- `schedule_tz` (string)
- `payload` (JSON)
- `dedupe_key` (string, optional)
- `next_run_at` (timestamp)
- `running_at` (timestamp)
- `last_run_at` (timestamp)
- `last_status` (`ok|error|skipped`)
- `last_error`
- `created_at`, `updated_at`

### 4.2 CronRun（运行记录）
- `run_id` (PK)
- `job_id`
- `trigger` (`timer|manual`)
- `status` (`ok|error|skipped`)
- `summary` (可选)
- `error` (可选)
- `duration_ms`
- `ts`

> Postgres 作为主存储；SQLite 仅测试使用。

---

## 5. 内置工具设计（schedule_task）

### 5.1 Tool Schema（与 EVA 对齐）
```json
{
  "action": "add|update|remove|enable|disable|get|list|run",
  "job": {
    "job_id": "string",
    "name": "string",
    "schedule": {
      "kind": "at|every|cron",
      "at": "2026-02-04T10:00:00+08:00",
      "every_ms": 3600000,
      "cron": "0 8 * * *",
      "tz": "Asia/Shanghai"
    },
    "session": "main|isolated",
    "payload": { "message": "..." },
    "enabled": true,
    "delete_after_run": false,
    "dedupe_key": "optional"
  }
}
```

### 5.2 工具提示词（对齐 EVA）
- 在 system prompt 中添加：
  - “可使用 `schedule_task` 设置提醒或周期任务”。

---

## 6. 执行与回传策略

### 6.1 调度循环
- 单定时器策略（类似 EVA）：只挂 **下一次唤醒**。
- 计算 `next_run_at`：
  - `at`: 固定时间
  - `every`: anchor + step
  - `cron`: cron 解析（Rust crate + tz）

### 6.2 执行模式
- `session = main`：直接触发该会话的智能体运行（payload.message 作为问题/系统事件）。
- `session = isolated`：
  - 先在独立会话执行任务
  - **执行成功后将结果写回原会话**
  - **触发原会话智能体续跑**

### 6.3 回传 + 续跑（核心需求）
- 每个任务保存 `user_id + session_id + agent_id`。
- 当任务执行成功：
  1) 写入运行记录（CronRun）。
  2) 将结果作为系统事件/消息写回原会话。
  3) 触发一次 `Orchestrator::run`，并 **在会话空闲时才执行**。
- **空闲检测**：
  - 使用现有 SessionLock 机制检测是否忙碌。
  - 若忙碌：将回传任务放入 pending 队列，按固定间隔重试（例如 2s-5s 退避）。

---

## 7. 任务执行流程（时序）

1) LLM 调用 `schedule_task add`。  
2) 后端创建 CronJob（记录 session_id/agent_id）。  
3) Scheduler 计算 next_run_at，并挂定时器。  
4) 到期触发：
   - 进入执行流程（main/isolated）。
   - 更新状态与日志。  
5) 执行完成：
   - 记录 run log。
   - 回写结果至原会话。
   - 若会话空闲，立即触发；若忙碌，进入 retry 队列。

---

## 8. API 设计（建议）

### 8.1 用户侧 API
- `GET /wunder/cron/list`（仅返回当前用户）
- `POST /wunder/cron/add`
- `POST /wunder/cron/update`
- `POST /wunder/cron/remove`
- `POST /wunder/cron/run`
- `GET /wunder/cron/runs?job_id=...`

### 8.2 管理侧 API（可选）
- `GET /wunder/admin/cron/list`（全量）
- `POST /wunder/admin/cron/update`（强制）

---

## 9. 前端设计（用户侧）

### 9.1 入口
- 在 **“工具管理”按钮后面**新增“定时任务”按钮。
- 点击弹出/跳转：任务管理页。

### 9.2 页面能力
- 列表字段：任务名 / 状态 / 下次执行 / 最近执行 / 结果状态
- 操作：启用/禁用/立即执行/删除
- 详情弹窗：schedule + payload + 最近 N 次执行记录

### 9.3 UI 规范
- 不使用 `backdrop-filter`。
- 需兼容浅色/深色主题。

---

## 10. 观测与稳定性

- 所有运行记录写入 CronRun。
- 错误记录：保存 error 字段 + last_error。
- 任务执行超时：标记 error + 重算 next_run。

---

## 11. 配置项建议

```yaml
cron:
  enabled: true
  max_concurrent_runs: 1
  idle_retry_ms: 2000
  cron_lookahead_days: 14
```

---

## 12. 实施步骤（建议顺序）

1) 后端：新增 CronJob/CronRun 表 + StorageBackend 扩展。
2) 后端：实现 SchedulerService（Rust async 版）。
3) 后端：内置工具 schedule_task + 系统提示词补充。
4) 后端：API 路由与权限校验。
5) 前端：工具管理入口新增“定时任务”按钮。
6) 前端：定时任务列表与详情页。

---

## 13. 待确认问题

已确认（2026-02-04）：
- 回传结果默认 **full**（完整输出）。
- 任务触发消息 role 为 **user**。
- 只要智能体拥有“定时任务”工具，即可使用，不做额外权限限制。

---

> 本方案为第一版落地设计，后续实现时按“后端调度 → 工具接入 → UI 管理”的顺序推进。
