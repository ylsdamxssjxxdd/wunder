# 用户世界落地方案

## 1. 背景与目标

当前用户侧前端已经具备“用户 ↔ 智能体”稳定通信能力，目标是在此基础上新增“用户世界（User World）”，让用户之间可以像微信一样直接聊天：

- 默认可看到其他用户（联系人列表）
- 选择用户后可直接进入会话
- 以 WebSocket 为主、SSE 为兜底
- 保持现有智能体聊天能力不受影响

---

## 2. 现状代码分析（基于当前仓库）

### 2.1 前端现状

1. 现有聊天页完全围绕“智能体会话”建模：
   - `frontend/src/views/ChatView.vue`（会话切换、消息渲染、发送/停止、外部会话同步）
   - `frontend/src/stores/chat.ts`（会话缓存、SSE/WS 流式处理、resume/watch、草稿会话）
2. 会话分组维度是 `agent_id`，而非“联系人用户”。
3. 发送链路固定走：
   - `POST /wunder/chat/sessions/{id}/messages`
   - `WS /wunder/chat/ws`（start/resume/watch/cancel）
4. 消息结构是 `user/assistant` 双角色，并内置工作流、推理过程、工具调用统计，不适合直接复用为“用户 ↔ 用户”消息模型。

### 2.2 后端现状

1. 聊天路由仅覆盖智能体会话：
   - `src/api/chat.rs`
   - `src/api/chat_ws.rs`
2. 关键校验均基于“会话归属 user_id”：
   - `get_chat_session(&user_id, &session_id)`
   - `list_chat_sessions(user_id, agent_id, ...)`
3. `build_chat_request` 会把用户输入提交到 orchestrator/agent runtime，天然是“用户 → 模型”的路径。
4. 普通用户无法通过用户侧接口获取“全用户目录”，目前用户列表在管理端：
   - `src/api/admin.rs` 的 `admin_user_accounts_list`

### 2.3 存储层现状与约束

1. `chat_sessions` 是单用户归属模型（`session_id` 主键 + `user_id` 字段）。
2. `chat_history` 查询条件是 `(user_id, session_id)`。
3. 这意味着“一个会话由两位用户共享”的场景，无法直接在现有 chat_* 模型中落地。

结论：用户世界不能直接复用 chat_* 数据模型，需要独立的用户通信域（API、服务、存储、前端 store）。

---

## 3. 需求拆解

### 3.1 功能需求（第一阶段）

- 联系人列表：默认显示所有可见用户（可搜索）
- 点对点会话：选择用户后进入聊天
- 消息发送与接收：实时到达
- 未读计数：联系人列表可见
- 消息历史分页：按时间或 message_id 倒序加载
- 读状态回写：打开会话时清未读

### 3.2 非功能需求

- WebSocket 优先，SSE 兜底
- 多端并发可用（同一用户多个前端实例）
- 权限安全（只能访问自己参与的会话）
- 低开销（联系人列表分页、消息分页、索引可命中）

---

## 4. 方案选型

### 方案 A：复用现有 chat_* 表（不推荐）

优点：改动少。  
缺点：`chat_sessions` 是单用户会话主键模型，强行复用会造成双份会话、双份历史、权限判断复杂且易错。

### 方案 B：新增 user_world_* 领域（推荐）

优点：语义清晰、权限边界明确、可持续扩展（群聊/拉黑/置顶/免打扰）。  
缺点：需要新增存储结构与 API。

**结论：采用方案 B。**

---

## 5. 后端落地设计（推荐实施）

## 5.1 新增数据模型

新增以下表（SQLite/Postgres 同步）：

1. `user_world_conversations`
   - `conversation_id` (PK)
   - `conversation_type`（先固定 `direct`）
   - `participant_a`、`participant_b`（按字典序存储，保证唯一）
   - `created_at`、`updated_at`、`last_message_at`
   - `last_message_id`、`last_message_preview`
   - 唯一索引：`(participant_a, participant_b)`

2. `user_world_members`
   - `(conversation_id, user_id)` (PK)
   - `peer_user_id`
   - `last_read_message_id`
   - `unread_count_cache`
   - `pinned`、`muted`
   - `updated_at`
   - 索引：`(user_id, updated_at DESC)`

3. `user_world_messages`
   - `message_id` (PK, 自增)
   - `conversation_id`
   - `sender_user_id`
   - `content`、`content_type`
   - `client_msg_id`（幂等）
   - `created_at`
   - 唯一索引：`(conversation_id, client_msg_id)`（非空时）
   - 索引：`(conversation_id, message_id DESC)`

4. `user_world_events`（用于 WS/SSE 断线续传）
   - `(conversation_id, event_id)` (PK)
   - `payload`
   - `created_time`
   - 索引：`(created_time)`、`(conversation_id, event_id)`

## 5.2 新增服务层

新增 `src/services/user_world.rs`：

- 会话归一化：`resolve_or_create_direct_conversation(user_a, user_b)`
- 发送消息事务：
  1) 插入 message  
  2) 更新 conversation 最新摘要  
  3) 更新双方 member unread/read  
  4) 追加 user_world_event
- 历史分页查询
- 联系人聚合查询（用户资料 + 会话预览 + 未读）
- 读状态更新

并在 `AppState` 中注入 `user_world` 服务实例。

## 5.3 新增 API 路由

新增 `src/api/user_world.rs`：

- `GET /wunder/user_world/contacts`
- `POST /wunder/user_world/conversations`（按 peer_user_id 获取或创建）
- `GET /wunder/user_world/conversations`
- `GET /wunder/user_world/conversations/{conversation_id}`
- `GET /wunder/user_world/conversations/{conversation_id}/messages`
- `POST /wunder/user_world/conversations/{conversation_id}/messages`
- `POST /wunder/user_world/conversations/{conversation_id}/read`
- `GET /wunder/user_world/conversations/{conversation_id}/events`（SSE resume）

鉴权全部复用 `resolve_user`；会话访问统一校验“当前用户必须是 member”。

## 5.4 新增 WS 路由

新增 `src/api/user_world_ws.rs`，协议复用现有 chat/core ws 风格：

- endpoint：`/wunder/user_world/ws`
- client 消息：`connect`、`watch`、`send`、`read`、`ping`、`cancel`
- server 消息：`ready`、`event`、`error`、`pong`
- 事件类型：`uw.message`、`uw.read`、`uw.contact_update`、`uw.final`

使用 in-memory 连接表维护用户在线连接，消息写库成功后实时 fanout 到会话双方在线连接。

## 5.5 权限与安全策略

- 默认联系人：所有 `active` 用户（可配置扩展过滤）
- 不允许伪造 sender：发送者始终取当前 token 用户
- 禁止跨会话读取：`conversation_id` 必须校验 member
- 文本长度、发送频率做限流（防刷）
- 第一阶段只支持纯文本（附件后续阶段扩展）

## 5.6 与现有智能体链路隔离

- 用户世界不经过 orchestrator，不消耗模型配额
- 不写入 chat_* / monitor 会话流水
- 与现有 `/wunder/chat/*` 并行存在，互不影响

---

## 6. 前端落地设计（微信式交互）

## 6.1 路由与页面

新增页面：

- `frontend/src/views/UserWorldView.vue`
- 路由：
  - `/app/user-world`
  - `/desktop/user-world`
  - `/demo/user-world`（可选）

入口建议：

1. `PortalView` 增加“用户世界”入口卡片（推荐）
2. `UserTopbar` 增加用户世界导航按钮

## 6.2 页面结构（微信式）

- 左侧：联系人列表（头像、昵称、最后一条、时间、未读）
- 右侧：当前会话（消息列表 + 输入框）
- 移动端：联系人页/会话页切换

样式建议沿用现有 `portal-shell` 变量体系，新增 `frontend/src/styles/pages/user-world.css`，同时补齐浅色主题变量，不使用 `backdrop-filter`。

## 6.3 状态管理

新增 `frontend/src/stores/userWorld.ts`：

- `contacts`
- `conversations`
- `activeConversationId`
- `messagesByConversation`
- `unreadByConversation`
- `presenceByUser`
- `loading/error`

新增 API 模块 `frontend/src/api/userWorld.ts` 与 WS 客户端封装，复用 `createWsMultiplexer`。

## 6.4 前端核心交互流

1. 页面初始化：拉取 contacts + conversations
2. 建立 WS 并 watch
3. 点击联系人：ensure conversation + 拉取历史
4. 发送消息：本地 optimistic 插入 + 服务端 ack 回写
5. 收到 `uw.message`：更新消息区与联系人预览
6. 打开会话后自动 read，清空未读
7. WS 不可用时降级 SSE（events + after_event_id）

---

## 7. 里程碑计划

### M1（后端基础）

- 新增 user_world_* 表与 storage 接口
- 完成 REST：contacts/conversation/messages/read
- 完成权限校验与幂等发送

验收：两个真实用户可通过 REST 完成互聊与历史拉取。

### M2（实时通道）

- 完成 `/wunder/user_world/ws`
- 完成 `/events` SSE resume
- 完成在线 fanout 与断线补偿

验收：A/B 双端实时收发，断线重连不丢消息。

### M3（前端页面）

- 完成 `UserWorldView` 与 `userWorld` store
- 完成入口接入与移动端适配
- 完成浅色/深色主题一致性

验收：交互达到“联系人选择即聊天”的微信式体验。

### M4（稳定性与治理）

- 发送限流、内容长度限制、异常告警
- 性能优化（分页、索引、缓存）
- 文档更新（设计/API/系统介绍）

---

## 8. 测试策略

后端：

- storage 单测：会话归一化、消息分页、unread 计算、幂等发送
- API 集成测试：权限越权、空内容、并发发送、read 回写
- WS 回归测试：watch/send/cancel/reconnect/resume

前端：

- store 单测：事件合并、未读计数、会话切换
- 手工联调：双账号双窗口实时聊天、弱网重连、主题切换

发布门槛：

- `cargo check`
- `cargo clippy`
- 前端 `npm run build`
- 关键路径双账号联调通过

---

## 9. 关键风险与规避

1. **会话归一化不一致**：统一按 `min(user_id), max(user_id)` 生成 direct conversation key。
2. **多端重复消息**：使用 `client_msg_id` + 唯一索引做幂等。
3. **未读计数漂移**：以 `last_read_message_id` 为真值，`unread_count_cache` 仅作加速缓存。
4. **WS 断线丢事件**：SSE + event_id 补偿，消息历史永远可回放。
5. **性能退化**：联系人分页、消息分页、严格索引、避免全表扫描。

---

## 10. 代码改造清单（落地时）

后端（Rust）：

- `src/storage/mod.rs`（新增 record + trait）
- `src/storage/sqlite.rs`
- `src/storage/postgres.rs`
- `src/services/user_world.rs`（新增）
- `src/core/state.rs`（注入服务）
- `src/api/user_world.rs`（新增）
- `src/api/user_world_ws.rs`（新增）
- `src/api/mod.rs`（挂载路由）

前端（Vue3）：

- `frontend/src/api/userWorld.ts`（新增）
- `frontend/src/stores/userWorld.ts`（新增）
- `frontend/src/views/UserWorldView.vue`（新增）
- `frontend/src/router/index.ts`（新增路由）
- `frontend/src/views/PortalView.vue`（新增入口）
- `frontend/src/components/user/UserTopbar.vue`（新增导航）
- `frontend/src/styles/pages/user-world.css`（新增并引入）
- `frontend/src/i18n/messages/zh-CN.ts`、`frontend/src/i18n/messages/en-US.ts`

文档（实施后同步）：

- `docs/设计方案.md`
- `docs/API文档.md`
- `docs/系统介绍.md`
- `docs/功能迭代.md`（按分类脚本写入）

