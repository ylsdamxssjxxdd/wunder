# 新渠道接入与内网激活方案（注册表版）

## 1. 结论（先说答案）

- 当前 wunder 已具备“渠道适配器注册表”架构，新增渠道可以走 **Rust 适配器 + 账号配置** 路径，不必再改核心分发分支。
- 你的“外网开发、内网落地”诉求可直接支持：在外网完成适配器代码与配置模板，内网拷贝后重新编译即可激活。
- 插件化方案方向正确，但建议分阶段推进；短期优先把“编译期可扩展”跑稳，避免一次性引入进程插件复杂度。

---

## 2. 当前架构下的最小接入面

新增一个渠道（例如 `acme_chat`）最少改动点：

1. 新增适配器实现  
   - 文件：`src/channels/acme_chat.rs`
   - 实现 `ChannelAdapter`：
     - `channel()`
     - `send_outbound()`（必选）
     - `verify_inbound()` / `parse_inbound()`（按需）

2. 注册到运行时注册表  
   - 文件：`src/channels/registry.rs`
   - 在 `build_default_channel_adapter_registry()` 增加 `register_replace(Arc::new(AcmeChatAdapter))`

3. 加入渠道目录（用于用户侧可见）  
   - 文件：`src/channels/catalog.rs`
   - 增加 `ChannelCatalogItem`

4. 模块导出  
   - 文件：`src/channels/mod.rs`
   - 增加 `pub mod acme_chat;`

> 说明：出站已是“注册表优先 + outbound_url 回退”，不会再改 `ChannelHub` 的渠道分支。

---

## 3. 配置建议（配置文件 + Rust 代码）

### 3.1 账号配置结构建议

在 `channel_accounts.config` 中为新渠道保留独立命名空间（示例）：

```json
{
  "inbound_token": "optional-token",
  "timeout_s": 10,
  "acme_chat": {
    "api_base": "https://api.acmechat.com",
    "app_id": "xxx",
    "app_secret": "yyy",
    "signing_secret": "zzz"
  }
}
```

### 3.2 代码读取方式建议

- 优先从 `context.account.config`（原始 JSON）读取你自己的 `acme_chat` 段并反序列化；
- 不强依赖 `ChannelAccountConfig` 增字段，减少主干类型耦合。

---

## 4. 外网开发 -> 内网激活标准流程

1. 外网开发
   - 完成 `src/channels/acme_chat.rs`
   - 更新 `registry/catalog/mod`
   - 提供 `config/acme_chat.account.template.json`（账号配置模板）
   - 提供最小联调脚本与回归清单

2. 交付物打包
   - Rust 源码补丁（或目录包）
   - 配置模板
   - 渠道联调文档（回调 URL、签名规则、测试数据）

3. 内网落地
   - 拷贝代码与配置模板到内网仓库
   - `cargo check` / `cargo build --release`
   - 通过用户侧 `/wunder/channels/accounts` 或运维脚本写入账号配置
   - 使用 `/wunder/channel/{provider}/webhook` 进行冒烟联调

4. 验收
   - 入站可解析
   - 出站可回包
   - outbox 重试生效
   - 监控可见（accounts/bindings/sessions）

---

## 5. 何时需要“专用 webhook 路由”

满足任一条件建议加专用路由（`src/api/channel.rs`）：

- 验签依赖账号密钥且必须先解析账号才能验签；
- 回调是 XML/加密二进制等非标准 JSON；
- 平台要求 challenge 特殊响应。

否则优先走通用 `/wunder/channel/{provider}/webhook` + 适配器钩子。

---

## 6. 对“渠道插件落地方案”的评估（docs/方案/渠道插件落地方案.md）

结论：**方向正确、长期合适、短期不建议一次性全量落地**。

- 合适点
  - 进程隔离插件能降低主进程风险；
  - 适合你提到的“外网开发、内网部署”协作模式；
  - 便于后续做插件生命周期治理（启停、版本、审计）。

- 需要与当前代码对齐的点
  - 文档里“outbox 硬编码分支”已在当前版本移除（已注册表化）；
  - admin 渠道面已收敛为监控只读，不宜再承载重配置流程；
  - 插件应对接现有 `ChannelAdapter` 抽象，优先做 `PluginBackedAdapter` 桥接，而不是平行再造一套渠道主链路。

- 建议节奏
  - P1：先保持“编译期扩展 + 注册表”主路径（当前已可用）
  - P2：补 `PluginBackedAdapter`（单一 JSON-RPC 协议）
  - P3：再做插件包安装/启停/签名校验
  - P4：最后落 UI 生命周期管理

---

## 7. 推荐落地决策

- 近期（可立即执行）：按“Rust 适配器 + 配置模板”接入你的内部新渠道。
- 中期（稳定后）：按插件方案推进 `PluginBackedAdapter`，先不改主链路数据模型。
- 长期：形成“内置适配器 + 外部插件”双轨，核心渠道内置，定制渠道插件化。
