# Wunder 配置与状态存储梳理（用于后续统一治理）

> 目标：把 wunder 里“会影响系统行为的配置/状态”按 **固定 vs 活动**、**本地文件 vs 数据库**、**server/cli/desktop** 三条维度梳理清楚，便于后续做统一治理、备份、审计与迁移。
>
> 说明：仓库内未发现名为“罗盘/compass”的独立模块或配置实体。下文中我按常见用法将“罗盘”理解为 **本地运行形态（CLI / Desktop）** 或 **管理端面板** 的“控制台/驾驶舱”。如果你这里的“罗盘”另有所指，请告诉我对应模块名/页面名/接口名，我再补一版对齐。

## 1. 核心配置分层与生效顺序

### 1.1 Base 配置（基础/固定）

- 默认基础配置文件：`config/wunder.yaml`
- 环境变量覆盖基础配置路径：`WUNDER_CONFIG_PATH`
- 若 `WUNDER_CONFIG_PATH` 指向的文件名为 `wunder.yaml` 且文件不存在，会自动回退读取同目录的 `wunder-example.yaml`
  - 典型：`config/wunder.yaml` 缺失时回退 `config/wunder-example.yaml`

### 1.2 Override 配置（活动/可变）

- 覆盖配置文件路径：`WUNDER_CONFIG_OVERRIDE_PATH`
- server 默认：`data/config/wunder.override.yaml`
- 覆盖文件的写入来源：
  - **管理端 API** 修改系统设置 -> 写入 override
  - override 按 **“与 base 的差异(diff)”** 方式落盘（只写变更字段）
  - 空字符串不会覆盖 base（避免把已有配置“清空”）

### 1.3 环境变量插值（活动/部署侧）

- `wunder.yaml` 支持 `${ENV}` 与 `${ENV:-default}` 形式占位符
- 合并 base + override 后，会对 YAML 值进行环境变量展开（expand）
- 注意：空字符串环境变量会被当作“未设置”（会走 `:-default` 或展开为空）

### 1.4 运行时保留的环境变量兜底

- 仍保留 `WUNDER_HOST` / `WUNDER_PORT` / `WUNDER_SERVER_MODE` 对监听地址与运行模式的兜底覆盖（便于容器化部署）

## 2. 三种运行形态：配置与状态落盘位置

### 2.1 Server（云端/服务形态）

固定配置（随代码/镜像发布）：

- `config/wunder.yaml`：基础配置（建议作为“声明式配置”主入口）
- `config/wunder-example.yaml`：示例/兜底
- `config/i18n.messages.json`：i18n 文案（可用 `WUNDER_I18N_MESSAGES_PATH` 改路径）
- `config/org_units.json`：组织架构种子文件（仅用于“数据库为空时”的初始化）
- `prompts/**`：默认系统提示词模板（default pack）

活动配置（运行期会变）：

- `data/config/wunder.override.yaml`：管理端写入的覆盖配置（可用 `WUNDER_CONFIG_OVERRIDE_PATH` 改路径）
- `data/prompt_templates/<pack_id>/prompts/**`：管理端编辑的提示词模板包（pack）
  - 生效 pack 由配置 `prompt_templates.active` 决定
- `data/user_tools/**`：用户自建/共享工具的文件化配置（见第 4 章）
- `workspaces/<user_id>/**`：每个 user_id 的工作区（长期资产）

数据库（活动状态，server 主要在 Postgres）：

- Postgres DSN：配置 `storage.postgres.dsn`（支持 `${WUNDER_POSTGRES_DSN:-...}`）
- “配置类/业务类”数据主要入库（见第 5 章表清单）

容器化部署（docker compose 默认，便于统一治理/备份）：

- docker compose 默认使用两个命名卷：
  - `wunder_workspaces`：挂载到 `/workspaces`（用户工作区 + 临时目录，`WUNDER_TEMP_DIR_ROOT` 默认 `/workspaces/temp_dir`）
  - `wunder_logs`：挂载到 PostgreSQL/Weaviate 数据目录（`/var/lib/postgresql/data`、`/var/lib/weaviate`）
- 运行态可写配置保留在仓库本地 `data/`（`data/config`、`data/prompt_templates`、`data/user_tools` 等），便于直观治理与迁移。
- 构建与依赖缓存（`target/`、`.cargo/`、`frontend/node_modules/`）保持写入仓库目录（bind mount），便于本地清理与管理。
- 注意：`docker compose down -v` 会删除 `wunder_workspaces` 与 `wunder_logs`；不会删除仓库本地 `data/`。如仅想“重置数据库”，应仅删除 `wunder_logs` 卷。

### 2.2 CLI（本地命令行形态）

CLI 会在启动时写入/设置一批运行时路径，核心在一个 temp_root 下（默认 `./WUNDER_TEMP`）。

固定配置来源（优先使用仓库配置）：

- 若仓库存在：`<repo>/config/wunder.yaml`（与 server 同一套）
- 若仓库不存在：自动生成 `WUNDER_TEMP/config/wunder.base.yaml` 作为 base（最小可运行配置）

活动配置与状态（都在 temp_root 下）：

- `WUNDER_TEMP/config/wunder.override.yaml`：CLI 运行时覆盖配置（与 server 同机制）
- `WUNDER_TEMP/config/extra_prompt.txt`：CLI 的 `/system set ...` 额外提示词（本质是“本地活动配置”）
- `WUNDER_TEMP/sessions/current_session.json`：CLI 保存的当前会话 ID（本地活动状态）
- `WUNDER_TEMP/wunder_cli.sqlite3`：CLI 本地 SQLite 数据库（“罗盘在数据库中”的典型形态）
- `WUNDER_TEMP/user_tools/<user_id>/config.json`：CLI 下的用户自建工具配置（文件）
- `WUNDER_TEMP/vector_knowledge/**`：向量知识库旧落盘结构的迁移根目录（新数据以 DB 为主）

工作区（CLI 的“真实产物目录”）：

- CLI 默认将 `workspace.root` 指向启动目录（current dir）
- CLI 默认启用 `WUNDER_WORKSPACE_SINGLE_ROOT=1`（单根目录模式）

### 2.3 Desktop（本地桌面形态）

Desktop 同样使用一个 temp_root（默认 `<app_dir>/WUNDER_TEMPD`），并额外有一份桌面端 settings。

固定/随包配置：

- `wunder-desktop/tauri.conf.json`：桌面端打包/能力声明（构建期配置）
- （同 CLI）若能访问仓库：`<repo>/config/wunder.yaml` 作为 base

活动配置（本地文件）：

- `WUNDER_TEMPD/config/desktop.settings.json`：桌面端设置（workspace_root、desktop_token、语言、container_roots、LLM 覆盖、remote_gateway 等）
  - 这是“罗盘在本地（文件）”最核心的一份
- `WUNDER_TEMPD/config/wunder.override.yaml`：Desktop 运行时覆盖配置（与 server 同机制）
- `WUNDER_TEMPD/config/wunder.base.yaml`：当仓库 base 不可用时自动生成

活动状态（本地数据库）：

- `WUNDER_TEMPD/wunder_desktop.sqlite3`：Desktop 本地 SQLite（“罗盘在数据库中”的典型形态）

工作区（桌面端真实资产目录）：

- 默认 `<app_dir>/WUNDER_WORK`，也可在 `desktop.settings.json` 或启动参数中指定
- 同 CLI：默认启用 `WUNDER_WORKSPACE_SINGLE_ROOT=1`

## 3. 仓库内“固定配置文件”清单（重点目录）

> 这部分建议纳入 Git 治理（评审/变更流程），作为“声明式配置”。

### 3.1 核心配置

- `config/wunder.yaml`：系统核心配置（server/cli/desktop 共用的主入口）
- `config/wunder-example.yaml`：示例配置（base 缺失时自动兜底）
- `.env` / `.env.example`：给 `docker-compose*.yml` 提供默认环境变量（Rust 程序本身不会自动读取 `.env`）
- `docker-compose-x86.yml` / `docker-compose-arm.yml` / `docker-extra/docker-compose-ubuntu20.yml`：容器化部署编排参数（含 `WUNDER_CONFIG_PATH` / `WUNDER_CONFIG_OVERRIDE_PATH`）
- `Dockerfile`：镜像构建相关参数

### 3.2 i18n / 渲染相关

- `config/i18n.messages.json`：系统文案（可用 `WUNDER_I18N_MESSAGES_PATH` 指向别处）
- `config/fonts.conf`：FontConfig 配置（docker-compose 里通过 `FONTCONFIG_FILE` 注入）
- `config/matplotlibrc`：Matplotlib 配置（docker-compose 里通过 `MATPLOTLIBRC` / `MPLCONFIGDIR` 注入）

### 3.3 组织/评估用例

- `config/org_units.json`：组织树种子（只在数据库为空时写入 DB）
- `config/evaluation/cases/*.json`：评估用例集（回归/靶场）

### 3.4 默认提示词模板（default pack）

- `prompts/zh/system/*.txt`
- `prompts/en/system/*.txt`

### 3.5 前端侧配置（固定文件 + 本地存储）

用户侧前端（Vue3）：

- `frontend/public/config.json`：前端运行时读取的轻量配置（如 `api_base`）
- `frontend/vite.config.ts` / `frontend/nginx.conf`：构建与本地开发/部署配置

管理员侧前端（web）：

- `web/app.config.js`：管理端面板默认配置（API Base / 轮询间隔 / 语言等）
  - 面板会把用户调整写入浏览器 `localStorage`（键：`wunder_app_config`），属于“客户端本地活动配置”

### 3.6 MCP Server（Python 侧）配置

- `mcp_server/mcp_config.json`：MCP 服务自身的外部依赖配置（数据库/RAG 等）
  - 注意：当前文件包含明文密钥/口令，后续统一治理时建议纳入“密钥治理”范围（迁到环境变量/密钥管理）

## 4. “活动配置文件”清单（运行期写入/可变）

> 这部分建议纳入统一治理：版本化、审计、备份与回滚。

### 4.1 系统覆盖配置（全局）

- server：`data/config/wunder.override.yaml`
- cli：`WUNDER_TEMP/config/wunder.override.yaml`
- desktop：`WUNDER_TEMPD/config/wunder.override.yaml`

### 4.2 管理端提示词模板包（全局）

- `data/prompt_templates/<pack_id>/prompts/{zh|en}/system/*.txt`
- pack 的“当前启用项”在配置 `prompt_templates.active`（通常由管理端写入 override）

### 4.3 用户自建工具（按 user_id 分区）

根目录由环境变量控制：`WUNDER_USER_TOOLS_ROOT`（默认 `data/user_tools`）。

典型结构（每个 user_id 一个目录）：

- `<root>/<safe_user_id>/config.json`：用户自建工具总配置（MCP/技能/知识库/共享工具开关）
- `<root>/<safe_user_id>/skills/**`：用户上传的 skills（活动文件）
- `<root>/<safe_user_id>/knowledge/**`：用户上传的“字面知识库”文档（活动文件）

### 4.4 工作区（按 user_id 分区，长期资产）

根目录由配置 `workspace.root` 控制（server 一般是 `./workspaces`，容器内常映射到卷）。

- `<workspace_root>/<safe_user_id>/**`：用户工作区文件（产物、附件、导入文件等）

## 5. 数据库中的“配置/状态”清单（需要与文件配置区分治理）

> 统一治理时，建议把 DB 数据分成两类：**配置类（可声明/可导入导出）** 与 **日志/过程类（可归档/可裁剪）**。

### 5.1 配置类（更接近“罗盘在数据库中”）

- `org_units`：组织结构（由 `config/org_units.json` 仅在初始化时填充，之后以 DB 为准）
- `user_accounts`：注册用户与角色/配额
- `external_links`：外链配置
- `user_agents`：智能体应用定义（用户创建/编辑）
- `hives`：编队/世界（若启用）
- `user_tool_access` / `user_agent_access`：访问控制策略（谁能用哪些工具/智能体）
- `channel_accounts` / `channel_bindings` / `channel_user_bindings`：渠道账号与绑定关系
- `gateway_nodes` / `gateway_node_tokens` / `gateway_clients`：网关节点、令牌与在线态
- `cron_jobs`：定时任务定义
- `memory_settings`：记忆策略开关/参数
- `vector_documents`：向量知识库文档元数据与切片信息（当前以 DB 为主，落盘目录仅做迁移兜底）

### 5.2 过程/日志类（更适合归档/裁剪）

- `chat_history` / `chat_sessions` / `session_runs` / `session_locks`：会话与运行记录
- `tool_logs` / `artifact_logs` / `monitor_sessions` / `stream_events`：可观测与流式事件
- `cron_runs`：定时任务执行记录
- `memory_records` / `memory_task_logs`：记忆内容与任务日志
- `evaluation_runs` / `evaluation_items`：评估运行与条目结果
- `channel_sessions` / `channel_messages` / `channel_outbox`：渠道会话/消息/出站队列
- `media_assets` / `speech_jobs`：多模态任务与资产
- `agent_threads` / `agent_tasks` / `team_runs` / `team_tasks`：智能体运行过程状态

## 6. 环境变量：配置路径与治理入口（最关键的一组）

建议后续统一治理时，将这些环境变量纳入“部署侧配置清单”：

- 配置分层
  - `WUNDER_CONFIG_PATH`：base 配置路径
  - `WUNDER_CONFIG_OVERRIDE_PATH`：override 配置路径
- 提示词 / i18n
  - `WUNDER_PROMPTS_ROOT`：默认提示词根目录（default pack，要求包含 `prompts/` 子目录）
  - `WUNDER_I18N_MESSAGES_PATH`：i18n messages JSON 路径
- 用户工具 / 向量知识迁移根目录
  - `WUNDER_USER_TOOLS_ROOT`：用户工具根目录
  - `WUNDER_VECTOR_KNOWLEDGE_ROOT`：向量知识旧落盘迁移根目录（新数据主要在 DB）
- 临时目录
  - `WUNDER_TEMP_DIR_ROOT`：`/wunder/temp_dir/*` 临时文件根目录（默认 `<cwd>/temp_dir`）
- 工作区行为
  - `WUNDER_WORKSPACE_ROOT`：工作区根目录（通常通过 `config/wunder.yaml` 的 `${WUNDER_WORKSPACE_ROOT:-...}` 注入）
  - `WUNDER_WORKSPACE_SINGLE_ROOT`：单根目录模式（CLI/Desktop 默认开启）
- 服务监听与模式
  - `WUNDER_HOST` / `WUNDER_PORT`
  - `WUNDER_SERVER_MODE`：`api` / `sandbox`
- 鉴权与外部依赖
  - `WUNDER_API_KEY`：API Key（`security.api_key` 也可引用该变量）
  - `WUNDER_GATEWAY_TOKEN`：网关共享 token
  - `WUNDER_POSTGRES_DSN` / `WUNDER_POSTGRES_POOL_SIZE`
  - `WUNDER_WEAVIATE_URL` / `WUNDER_WEAVIATE_API_KEY`
  - `WUNDER_SANDBOX_ENDPOINT`
- 本地运行专用
  - `WUNDER_CLI_PROJECT_ROOT`：CLI 指定 repo_root
  - `WUNDER_DESKTOP_SETTINGS_PATH` / `WUNDER_DESKTOP_APP_DIR` / `WUNDER_DESKTOP_DEFAULT_WORKSPACE_ROOT`
  - `WUNDER_SKILL_RUNNER_PATH` / `WUNDER_PYTHON_BIN`

## 7. 后续统一治理：建议的“权威来源（Source of Truth）”划分（草案）

- **声明式、可代码评审**：`config/wunder.yaml`、`prompts/**`、`config/i18n.messages.json`、`docker-compose*.yml`
- **运行时可写、需审计**：`data/config/wunder.override.yaml`、`data/prompt_templates/**`、`data/user_tools/**`
- **业务权威**：Postgres（org/users/agents/access/channels/gateway/cron/vector_documents 等）
- **客户端本地**：管理端面板 `localStorage(wunder_app_config)`、Desktop 的 `desktop.settings.json`

建议你后续做统一治理时，优先落 3 件事：

1) 做一份“全量导出/快照”（base + override + prompt packs + user_tools + DB 配置表）。
2) 明确哪些字段允许管理端写 override、哪些必须走 DB（有审计/权限）。
3) 把密钥类配置（如 `mcp_server/mcp_config.json` 里的 key/password）迁移到环境变量或独立密钥管理。

## 8. 是否要把 `data/**` 整合进 Postgres？（建议与影响）

结论（推荐做“分层整合”，而不是把所有文件都塞进 DB）：

- `data/prompt_templates/**` 与 `data/user_tools/**` 里 **“配置/文本内容”** 可以整合到 Postgres，能显著提升一致性、审计与多实例部署能力。
- 但 `workspaces/**` 这类 **大文件/产物/附件** 不建议入库；更推荐保留文件系统（或对象存储），DB 只存元数据与索引。

### 8.1 适合整合进 Postgres 的内容（优先级从高到低）

1) 系统活动配置（原 `data/config/wunder.override.yaml`）
   - 目标：多实例共享、可审计、可回滚、可版本化。
   - 现实约束：启动必须先拿到 DB DSN，因此仍需要 `config/wunder.yaml`/环境变量作为 bootstrap；DB 作为“运行期权威覆盖”。

2) Prompt Templates（原 `data/prompt_templates/<pack_id>/...`）
   - 内容：`pack_id + locale + segment_key -> content(text)`。
   - 特点：体积小、读多写少，非常适合入库；并可天然做版本号/审计日志。

3) 用户工具配置（原 `data/user_tools/<user>/config.json`）
   - 内容：MCP servers、skills enabled/shared、knowledge bases、shared_tools 等（JSON/JSONB）。
   - 特点：纯配置数据，入库后可以做“按组织/角色”的统一治理与审计。

4) 用户上传的 skills/knowledge（原 `data/user_tools/<user>/skills/**`、`.../knowledge/**`）
   - 如果你希望“统一备份/统一权限/统一审计”，可以把 **文件内容本身** 入库（text/bytea）。
   - 若担心 DB 膨胀与备份耗时，也可采用折中：文件仍落盘，但在 DB 记录 `path/hash/size/updated_at/owner`，把“治理”入库，把“内容”留在文件系统或对象存储。

### 8.2 不建议整合进 Postgres 的内容

- `workspaces/**`：用户工作区文件（产物、附件、临时中间文件、压缩包等）
  - 原因：I/O 模式像文件系统，不像结构化数据；入库会快速膨胀、拖慢备份/恢复与 vacuum，并放大热点读写成本。
- `fonts/**`、`web/**`、`frontend/**`：静态资源/依赖（应随构建产物走发布管线）

### 8.3 会影响性能吗？关键看“热路径是否仍走缓存”

如果把上述配置/模板直接改成“每次请求都查 DB”，性能一定会受影响；但按以下方式实现，性能通常不会比文件差，甚至可能更好：

- **内存缓存 + 版本号失效**：和现在对 prompt 的 revision 思路一致，但 revision 来源从“文件写入 bump”变成“DB 写入 bump”（可用单行 `version` 表）。
- **变更通知**：用 Postgres `LISTEN/NOTIFY` 或轮询 `updated_at/version`，做到配置改动秒级生效且不打爆 DB。
- **只在写入时触发重算**：例如 prompt pack 更新 -> bump revision -> 让 PromptComposer 缓存失效；平时构建 prompt 不访问 DB。

对于提示词/配置这类“小对象”，入库后真正的性能风险一般来自：

- 缓存策略缺失（导致每轮都查 DB）
- 把“大文件内容”（尤其是工作区产物）也塞进 DB（导致 DB 体积/备份/vacuum 成本暴涨）

### 8.4 还能整合哪些？

- `mcp_server/mcp_config.json`：目前含明文口令/密钥且与主系统治理脱节，建议至少做到：
  - 配置项迁到环境变量/密钥管理；或
  - 由 wunder-server 作为“配置中心”提供读取接口，mcp_server 启动时拉取（并缓存）。
- 管理端面板默认配置：`web/app.config.js` 目前是前端代码常量 + localStorage；可以增加一个服务端配置接口（落 DB），实现“统一下发默认值”（localStorage 仍可覆盖）。

### 8.5 推荐的迁移路径（不破坏现有行为）

1) 先做“写入双写（DB + 文件）”，读取仍以文件为主，保证回滚容易。
2) 然后切换“读取优先 DB，文件兜底”，并加 revision/cache，确保热路径不查 DB。
3) 最后再决定是否弃用 `data/**`（或把 `data/**` 改成纯缓存目录，而非权威来源）。

## 9. Docker 持久化卷的备份与迁移（换机部署）

wunder 的 docker compose 默认把运行态状态分成三类（便于迁移与治理）：

- 本地目录（bind mount）：`./data/**`（运行态可写配置与内容：override、prompt_templates、user_tools、vector_knowledge 等）
- 命名卷 `wunder_workspaces`：挂载到 `/workspaces`（用户工作区 + 临时目录；`WUNDER_TEMP_DIR_ROOT` 默认 `/workspaces/temp_dir`）
- 命名卷 `wunder_logs`：供 PostgreSQL/Weaviate 使用（分别挂载到 `/var/lib/postgresql/data`、`/var/lib/weaviate`，并通过 `PGDATA`/`PERSISTENCE_DATA_PATH` 落到子目录）

构建/依赖缓存（`target/`、`.cargo/`、`frontend/node_modules/`）默认在仓库目录（bind mount）中，便于本地清理与管理。

### 9.0 一键脚本（推荐）

- 卷备份（`wunder_logs` + `wunder_workspaces`）：`powershell -ExecutionPolicy Bypass -File scripts/backup_persist_volume.ps1`
- 卷恢复：`powershell -ExecutionPolicy Bypass -File scripts/restore_persist_volume.ps1 -InFile .\\backups\\wunder-volumes-<project>-xxxx.tgz`
- 本地 `data/`：直接复制整个 `data/` 目录（它不在 docker volume 里）
- 默认行为：脚本会先 `docker compose down`，完成后再 `up -d`；可用 `-NoStop`/`-NoStart` 控制。

### 9.1 简单迁移（停机 + 整卷打包，适合同版本快速搬家）

> 建议先停机再做文件级备份，避免 Postgres/Weaviate 处于写入中导致备份不一致。

1) 停止服务（不要加 `-v`）：

```bash
docker compose -f docker-compose-x86.yml down
```

2) 备份本地 `data/`（直接拷贝目录即可）：

```powershell
Copy-Item -Recurse -Force .\\data .\\data-backup
```

3) 找到卷名（用 label 更稳，不依赖具体前缀）：

```bash
docker volume ls --filter label=com.docker.compose.project=wunder --filter label=com.docker.compose.volume=wunder_workspaces --format "{{.Name}}"
docker volume ls --filter label=com.docker.compose.project=wunder --filter label=com.docker.compose.volume=wunder_logs --format "{{.Name}}"
```

4) 备份卷到当前目录（PowerShell，示例用 `postgres:16` 做 tar，避免引入额外镜像）：

```powershell
$ws = "wunder_wunder_workspaces"
$logs = "wunder_wunder_logs"
docker run --rm --user 0 -v ${ws}:/from -v ${PWD}:/backup postgres:16 bash -lc "cd /from && tar -czf /backup/wunder_workspaces.tgz ."
docker run --rm --user 0 -v ${logs}:/from -v ${PWD}:/backup postgres:16 bash -lc "cd /from && tar -czf /backup/wunder_logs.tgz ."
```

5) 新机器上：先部署代码仓库（git clone 或拷贝），再恢复卷（同时把 `data/` 目录拷贝过来）：

```powershell
docker volume create wunder_wunder_workspaces | Out-Null
docker volume create wunder_wunder_logs | Out-Null
docker run --rm --user 0 -v wunder_wunder_workspaces:/to -v ${PWD}:/backup postgres:16 bash -lc "cd /to && tar -xzf /backup/wunder_workspaces.tgz"
docker run --rm --user 0 -v wunder_wunder_logs:/to -v ${PWD}:/backup postgres:16 bash -lc "cd /to && tar -xzf /backup/wunder_logs.tgz"
```

6) 启动：

```bash
docker compose -f docker-compose-x86.yml up -d
```

### 9.2 更稳的迁移（DB 逻辑备份 + 文件状态打包，适合升级/跨版本）

如果你计划升级 Postgres/Weaviate 版本，或希望更可控/可审计，推荐用“逻辑备份”为主：

- Postgres：用 `pg_dump`/`pg_dumpall` 导出，在新库导入（比文件级拷贝更稳、也更适合跨版本升级）。
- Weaviate：可停机复制 `weaviate/` 分区；若启用官方 backup module（S3/GCS/Azure 等）则优先用其备份/恢复能力。
- `data/`：直接打包/拷贝本地目录。
- `wunder_workspaces`：用 tar 打包卷；如无需保留临时文件可仅保留用户目录。
