# 上下文压缩实战示例（max_context=9000）

本文记录真实压缩测试的流程与观测点，便于后续快速复现与对比。测试入口使用 `/wunder`，必须开启 `debug_payload: true`。

## 通用准备
1) 入口与请求参数  
   - 入口：`POST http://127.0.0.1:18000/wunder`  
   - 必须：`debug_payload: true`  
   - 建议：`skip_tool_calls: true`、`tool_names: ["__no_tools__"]`  
2) 监控与日志  
   - `monitor_payload_max_chars=0`，避免 payload 被截断  
   - 必要时将 `observability.log_level=DEBUG` 打开  
3) 采集 SSE 事件  
   - 关注事件：`context_usage`、`compaction`、`llm_request`、`round_usage`、`final`  
4) 统一记录格式  
   - 记录字段：`round`、`context_tokens`、`compaction.status/reason`、`summary_role`、`payload_omitted`、`CHECK missing`  

示例中的“观测结果”来自本次实际测试，可直接作为对照基线。

## 示例 1：多轮压缩触发（会话 S1）
**目标**：确认压缩触发点与触发后的上下文长度回落。  
**场景**：长规格说明 + 多轮输入 + 压缩触发。  

步骤：
1) 发送 R1：包含业务目标 + 90 行 FUNC + 80 行 NFR。  
2) 发送 R2：包含 90 行字段 + 70 行 API 列表。  
3) 发送 R3：包含 90 行指标 + 运维说明。  
4) 观察 `compaction` 事件与 `context_usage`。  

验证点：
- `compaction.status == "done"`，`reason == "history"`  
- `context_tokens` 明显下降  
- `payload_omitted` 不出现（证明完整请求体已记录）  
- 主请求 `messages` 中的 `[Context Summary]` 角色为 `user`（当前实现）  

观测结果（本次）：
- S1-3 触发 compaction，`context_tokens=2598`  
- `summary_role=user`  
- `payload_omitted` 未出现  

## 示例 2：压缩后关键参数保留（第一次 CHECK）
**目标**：压缩后仍能完整输出 k=v 参数。  
**场景**：在 S1-3 压缩后继续对话并执行 CHECK。  

步骤：
1) 发送 CHECK：要求输出一行 k=v，包含 15 项关键参数。  
2) 检查输出是否包含全部参数。  

验证点：
- `missing=[]`  

观测结果（本次）：
- S1-5 CHECK 完整，`missing=[]`  

## 示例 3：二次压缩后关键参数保留（第二次 CHECK）
**目标**：多次压缩后仍能保留关键参数。  
**场景**：继续叠加上下文，触发第二次压缩后再 CHECK。  

步骤：
1) 继续发送长文本（SEC/PERF 大列表）。  
2) 观察第二次 `compaction` 事件。  
3) 再次发送 CHECK。  

验证点：
- 第二次 `compaction.status == "done"`  
- `context_tokens` 再次回落  
- CHECK 仍为 `missing=[]`  

观测结果（本次）：
- S1-7 触发 compaction，`context_tokens=3462`  
- S1-9 CHECK 完整，`missing=[]`  

## 示例 4：附件在压缩后仍保留（会话 S2b）
**目标**：确认压缩后当前轮次附件未丢失。  
**场景**：在触发 compaction 的轮次携带文本附件。  

步骤：
1) 构造 2 轮较长文本，为第 3 轮压缩做铺垫。  
2) 第 3 轮发送文本附件（`text/plain`）。  
3) 观察 compaction 事件与请求 payload 中附件标签。  

验证点：
- `compaction.status == "done"`  
- 主请求 `payload.messages` 中出现附件标签  
  - 标签为：`The content of the file provided by the user`  

观测结果（本次）：
- S2b-3 触发 compaction  
- `attachment_label_found=true`  

## 示例 5：未触发压缩的基线（会话 S3）
**目标**：验证低上下文占用不会误触发压缩。  
**场景**：3 轮较短输入。  

步骤：
1) 发送 2 轮短文本 + 1 次 CHECK。  
2) 观察是否有 compaction 事件。  

验证点：
- `compaction_events == 0`  
- `context_tokens` 始终较低  

观测结果（本次）：
- S3-1~S3-3 无 compaction  
- `context_tokens` 最高 2290  

## 常见问题处理
- 看到 `payload_omitted: true`：说明未开启 `debug_payload` 或被截断。  
- 出现乱码：设置 `PYTHONIOENCODING=utf-8`，或仅用 ASCII 测试文本。  
- 短文本也触发压缩：核对 `max_context` 与 `history_compaction_ratio` 配置。  
